<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>🛠️Project &amp; Post on xym-ee</title>
    <link>https://xym.work/blog/</link>
    <description>Recent content in 🛠️Project &amp; Post on xym-ee</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 04 Sep 2024 10:00:00 +0800</lastBuildDate>
    <atom:link href="https://xym.work/blog/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>[post] 使用 gcc 开发 STM32</title>
      <link>https://xym.work/blog/baremetal.html</link>
      <pubDate>Wed, 04 Sep 2024 10:00:00 +0800</pubDate>
      <guid>https://xym.work/blog/baremetal.html</guid>
      <description>使用 gcc 开发 STM32 有 keil IAR 等 IDE，还要在 ubuntu 环境下使用 gcc 来开发 stm32 看起来似乎吃力不讨好。但是掌握这个技能的真正含义是：&#xA;拿到任意一块使用 arm cortex-m 内核的全新设计的芯片，只有芯片手册甚至还没有 IDE 可以使用的时候，使用 C 语言和一些 arm 汇编，以及交叉编译工具，是可以把这个芯片使用起来的。&#xA;更实际的情况是，一些大的裸机项目比如 u-boot，甚至 linux kernel 都是没有 IDE 用的，开发、调试这些项目的工具正是裸机开发 stm32 的这套工具。从一个简单的芯片开始去学习这一流程、练习相应工具的使用。&#xA;我的环境&#xA;ubuntu 22.04 STM32F103C8T6 64K flash 20K ram st-link v2 13.3.rel1-x86_64-arm-none-eabi 最简单的程序 int main() { return 0; } `` 为了让这个函数能在 CPU 上执行，还需要做到芯片通电后跳转到 main 入口。 ```c __attribute__((naked, noreturn)) void _reset(void) { extern long _sbss, _ebss, _sdata, _edata, _sidata; for (long *dst = &amp;amp;_sbss; dst &amp;lt; &amp;amp;_ebss; dst++) *dst = 0; for (long *dst = &amp;amp;_sdata, *src = &amp;amp;_sidata; dst &amp;lt; &amp;amp;_edata;) *dst++ = *src++; main(); // Call main() for (;;) (void) 0; // Infinite loop in the case if main() returns } 想让这个函数通电就执行，需要准备好 C 语言的运行环境，以及指定这个函数的地址，即程序员和硬件的约定，查看 m3 权威指南</description>
    </item>
    <item>
      <title>[project] 2019 年恩智浦杯大学生智能汽车竞赛，代码 review</title>
      <link>https://xym.work/blog/2019-nxp-car.html</link>
      <pubDate>Fri, 30 Aug 2024 10:00:00 +0800</pubDate>
      <guid>https://xym.work/blog/2019-nxp-car.html</guid>
      <description>比赛视频&#xA;比赛用车&#xA;0.介绍 2019 年 7 月分我参加了当年的恩智浦杯智能汽车竞赛，以前叫飞思卡尔杯，对于自动化专业来说，这个比赛还是挺重要的。当时我大三，这个比赛(项目)算是我的第一个完成度比较高的作品。我负责的内容，硬件开发，驱动开发，整个软件框架的开发。&#xA;这辆车也一直放在我身边，当时可能只是感兴趣觉得好玩，现在看起来这应该是我整个嵌入式开发生涯的起点。现在的我能给出更好地方案，更完整的设计，甚至更高效的代码结构。但是让我去评价当年的写这些代码的自己，我觉得做的已经不错了，这是一个项目总结，同时也是一个关于如何写出好代码的一些想法。&#xA;这个车的主控芯片为 NXP imx 的跨界处理器，使用 IAR 完成裸机开发。当时大量的参考了 NXP 官方的源码，虽然是裸机开发但是当时也通过 NXP 例程学习了不少东西，后面的内容我会详细写出来。&#xA;1.比赛要求，智能车工作原理 固定元素，实现智能车的自动运行。&#xA;赛道上出现的元素 赛道对比度比较高，摄像头是一定需要的。此外赛道上还铺设了电磁引导线，通着交流电，也可以通过磁场定位。赛道上还有障碍物，是显眼的红色。 需要摄像头，电磁传感器 障碍物 底盘控制 舵机 两个直流电机 硬件上，要考虑电机、舵机驱动，电磁传感器模拟信号的处理，整车供电。&#xA;车辆控制上，需要考虑通过图像获得智能车相对于赛道的偏差，这部分内容由我的队友负责，通过偏差计算出舵机的控制量，这部分也由我的队友负责。相当于我搭建一个比较可靠的运动平台，并提供控制算法需要的原始数据，然后将控制算法的输出落实到执行机构如电机、舵机。&#xA;2.硬件方案设计 我已经有几年不做硬件不画板了，但是这个项目是我比较完整的软硬件都做的项目，这里一定要拿出来介绍一下。使用 Altium Designer 来开发。考虑整车的电源设计，驱动板设计，电磁传感器设计，MCU 控制板的设计。&#xA;这个车的硬件还是比较简单的，MCU 用的 BGA 封装芯片使用了核心板，底板引出传感器和控制接口，做好供电设计。此外电机驱动与集成的半桥驱动芯片，两个芯片组成一个 H 桥直流电机驱动电路。再就是电池传感器，赛道上的交流电频率是 20KHz，根据磁场频率选择合适的电感和电容组成一个 LC 电路，在磁场中电感两端就会有电压信号，然后做放大检波等处理输入到 ADC 接口即可。&#xA;3.软件总体方案设计 这里由于软件设计上的不完善，只能通过 main 函数主循环的实现来猜测当时的设计想法了&#xA;int main(void) { /* --------------------- 硬件初始化 -------------------------- */ system_init();/* MCU初始化 */ //car_direction_barrier_test();/* 单个功能测试函数位置 */ lpuart1_init(115200); /* 蓝牙发送串口启动 */ key.init(); /* 按键启动 */ led.</description>
    </item>
    <item>
      <title>[project] 2019 年电子设计竞赛：模拟电磁曲射炮设计</title>
      <link>https://xym.work/blog/curved-fire-gun.html</link>
      <pubDate>Fri, 30 Aug 2024 10:00:00 +0800</pubDate>
      <guid>https://xym.work/blog/curved-fire-gun.html</guid>
      <description>源码仓库 0.简介 我参加了 2019 年全国大学生电子设计竞赛，当时我大三。选的题目是模拟电池曲射炮设计。赛题要求是设计制作一个电磁炮模型，通过视觉识别指定元素，自动发射射击。&#xA;电磁炮与环形靶的位置示意如图所示。电磁炮放置在定标点处，炮管初始水平方向与中轴线夹角为 $ 0 \degree $ 、垂直方向仰角为 $ 0 \degree $ 。环形靶水平放置在地面，靶心位置在与定标点距离 $ 200 \text{cm} \le d \le 300 \text{cm} $ ，与中心轴线夹角 $ \alpha \le \pm 30 \degree $ 的范围内。&#xA;需要实现的功能&#xA;炮弹的发射和命中功能 最基本的发射功能 对发射距离的控制 有视觉检测功能 炮管左右运动的功能 这个东西应该是硬件设计的内容占了60%，需要设计出合适的发射装置，使得可以通过 MCU 控制发射距离。视觉检测目标然后和转动到目标角度都要在能成功发射并命中的前提下才有意义。&#xA;先看当时实现的参赛作品&#xA;精度控制效果&#xA;精度还是不错的，拿了江苏省一等奖，实际上我们已经进入全国总测评了，如果总测评过了就是全国一等奖，没过是国二。但是呢，作品可能在路上出问题了，然后就退回省一了😂。还是比较可惜的，好在学校的比赛出问题都是小问题，如果这是工作上的失误那可能要出大问题。&#xA;23 年，有人觉得这个东西挺好玩的，是一个不错的教学用具，然后我在比赛的基础上，重新基于 RTOS 写了代码，并且做的更细致了一些。&#xA;1.2019电赛版电磁炮的设计思路 实现赛题要求需要 3 部分，充能与发射装置、云台、视觉检测，当时主控芯片选的是 NXP imx rt1052，此外还有显示屏、按键等完成交互操作。和电机控制类似，这也是个典型的低压控制高压的电子系统。整体上的设计如图所示&#xA;先考虑充能和发射装置，发射的基本原理：电感线圈流过电流时产生一个磁场，用磁场对磁性炮弹有一个作用力，完成对炮弹的发射。&#xA;这个感生磁场还不能一直存在，否则前段加速炮弹，后段会阻碍炮弹。也就是说线圈要通过瞬间的大电流，因此就需要大容量的电容来对线圈放电，刚好能实现比较好的发射效果。此外还需要配套的充电装置和放电开关，还需要实时检测电容充电电压以控制电容中的储能量，这是对炮弹发射距离控制的关键。&#xA;由于比赛时使用的是锂电池供电，因此为了能给电容充电到一个比较高的电压，需要逆变器和整流器，对于充电通断的控制可以使用继电器来实现。电容电压检测则需要使用分压电阻分压然后做隔离送入 MCU 的 ADC 端口。电容对发射线圈的放电开关需要使用晶闸管，使用继电器的话触点常容易损坏。&#xA;因此高压部分的原理上为下面这个图&#xA;细节上的实现&#xA;把发射模块看做一个整体，有这些输入输出引脚输出接口&#xA;GPIO_IN, 充电控制 GPIO_IN, 发射控制 AD_OUT, 充电电压反馈 云台使用舵机云台就可以，这个任务里 openmv 就可以胜任识别的工作，openmv 和控制板使用串口通信，openmv 只需要发送回目标的横坐标即可。</description>
    </item>
    <item>
      <title>[project] ROS 智能车算法验证平台开发</title>
      <link>https://xym.work/blog/ackerman-chassis.html</link>
      <pubDate>Fri, 30 Aug 2024 10:00:00 +0800</pubDate>
      <guid>https://xym.work/blog/ackerman-chassis.html</guid>
      <description></description>
    </item>
    <item>
      <title>[project] ROS 机器人底盘开发，差速底盘和阿克曼底盘</title>
      <link>https://xym.work/blog/ros-chassis.html</link>
      <pubDate>Fri, 30 Aug 2024 10:00:00 +0800</pubDate>
      <guid>https://xym.work/blog/ros-chassis.html</guid>
      <description>模拟联合收割机器人&#xA;模拟自动驾驶&#xA;0.介绍 自主移动机器人，导航，为了导航需要地图，还需要定位。&#xA;最后是运动，我主要做机器人的底盘开发和运动控制这块的内容。&#xA;1.ROS 差速底盘开发 这里主要介绍一下差速底盘的里程计计算&#xA;rt_mutex_take(status_mutex, RT_WAITING_FOREVER); status.chassis.motor_lf.v_feedback = v_lf; status.chassis.motor_lb.v_feedback = v_lb; status.chassis.motor_rf.v_feedback = v_rf; status.chassis.motor_rb.v_feedback = v_rb; /* 里程计数据解算 */ #define L 0.23f /* 左右轮间距 */ v_l = (v_lf + v_lb)/2.0f; v_r = (v_rf + v_rb)/2.0f; status.info_send.speed_x = (v_l + v_r) / 2.0f; status.info_send.speed_y = 0.0f; status.info_send.speed_angular = -(v_l - v_r) / L / 2.0f; status.info_send.pose_angula += 0.93f * status.info_send.speed_angular*DELAY_TIME; status.info_send.pose_angula = angle_to_limit(status.info_send.pose_angula); status.info_send.position_x += status.</description>
    </item>
    <item>
      <title>[project] 使用麦克纳姆轮底盘的一些机器人运动控制项目</title>
      <link>https://xym.work/blog/mecanum-chassis.html</link>
      <pubDate>Fri, 30 Aug 2024 10:00:00 +0800</pubDate>
      <guid>https://xym.work/blog/mecanum-chassis.html</guid>
      <description>0.简介 这一部分总结一下我以前做过的使用麦克纳姆轮底盘的机器人的一些小项目。&#xA;底盘运动控制，麦克纳姆轮底盘分析，运动学解算，4 个电机速度和空间速度的关系。使用遥控器控制实现底盘的平移和旋转运动&#xA;在此基础上，加一个位置控制器，实现空间位置的跟踪控制，空间目标位置可以使用 UWB 定位或者视觉检测 airtag 等，这里给一个识别 airtag 的演示，使用 openmv 的到标签的距离，并控制底盘保持距离恒定。&#xA;1.麦克纳姆轮底盘的控制原理 设定一个底盘坐标系，其中：&#xA;x 轴：沿机器人前方的方向（前进方向）。 y 轴：沿机器人右侧的方向（侧向）。 z 轴：垂直于地面（向上）。 已知底盘空间速度求个轮子的速度。反解&#xA;$$ \left [ \begin{array}{} v_1 \\ v_2 \\ v_3 \\ v_4 \\ \end{array} \right ] = J \left [ \begin{array}{} v_x \\ v_y \\ v_z \\&#xA;\end{array} \right ] $$&#xA;一个底盘速度空间到四轮转速空间的变换。通过对麦克纳姆轮的分析，速度合成然后结算后，这个变换矩阵为&#xA;$$ J = \left [ \begin{array}{} 1 &amp;amp; -1 &amp;amp; L + W \\ 1 &amp;amp; 1 &amp;amp; - (L + W) \\ 1 &amp;amp; 1 &amp;amp; L + W \\ 1 &amp;amp; -1 &amp;amp; - (L + W) \\ \end{array} \right ] $$</description>
    </item>
    <item>
      <title>[project] 全向舵轮底盘运动控制软件开发</title>
      <link>https://xym.work/blog/omni-chassis.html</link>
      <pubDate>Fri, 30 Aug 2024 10:00:00 +0800</pubDate>
      <guid>https://xym.work/blog/omni-chassis.html</guid>
      <description>0.介绍 一种全向底盘的类型是麦克纳姆轮底盘，还有一种类似行李箱轮的结构，轮子本身可以 $ 360 \degree $ 受控的旋转，即舵轮。&#xA;项目来源&#xA;1.舵轮底盘控制原理 几种模式&#xA;$$ \left { \begin{array}{l} r_2 \cos \theta_2 - r_1 \cos \theta_1 = 2a \ r_1 - r_1 \cos \theta_1 + a = r \ r_2 \cos \theta_2 = r + a \ r_1 \sin \theta_1 = a \ r_2 \sin \theta_2 = a \ \end{array} \right . $$&#xA;先搞走三角函数，计算内外圆的半径&#xA;由后面四个式子&#xA;$$ \cos \theta_1 = \frac{r_1 + a - r}{r_1} $$</description>
    </item>
    <item>
      <title>[project] 循迹类比赛总结：控制方法和代码结构</title>
      <link>https://xym.work/blog/tracking-robot.html</link>
      <pubDate>Fri, 30 Aug 2024 10:00:00 +0800</pubDate>
      <guid>https://xym.work/blog/tracking-robot.html</guid>
      <description>0.介绍 实习期间项目，实习公司卖教育机器人的套件，并且是比赛主办方，需要比赛配套的示例代码。实习之前我参加过一些比赛了，我做的第一个比赛就是循迹车，正好总结一下。&#xA;循迹类机器人比赛，使用灰度传感器识别色差比较明显的线，完成规定任务的比赛。我的整个嵌入式生涯、STM32 的第一个完整作品就是一辆循迹小车，去参加学校的机器人比赛。比赛要求是从指定的位置出发，然后沿着白线在规定的时间里去尽可能多的地方。&#xA;当时自己买了配件，画了底板，在宿舍搭了第一个车&#xA;就以这个比赛，分析一下如果想做好，控制上和代码上需要考虑的一些问题。&#xA;按照机器人开发的思路，分为路径、控制、定位、代码结构几个部分。&#xA;路径 考虑路径之前，先考虑怎么按照一个给定的路径走。&#xA;先用一个简化的图举例，给每个点都标上号，给出一个路径点序列，这就是一条要走的路。&#xA;对于这个比赛，需要知道车在哪里，下一点要去哪里。可以用状态来思考，一条路径的每个点都是一个状态，一个状态的下一个状态是确定的，然后根据当前状态，一步一步转移，最终到终点&#xA;先看一个按照这个思路设计的演示视频&#xA;程序上的一个大概得思路&#xA;void auto_run(unsigned char location, unsigned char destination) { if (destination &amp;gt; location) /* 正向运行 */ { for (int i = location + 1; i &amp;lt;= destination; i++) { auto_drive_fun_lst(i); } } else if (destination &amp;lt; location) /* 反向运行 */ { for (int i = location - 1; i &amp;gt;= destination; i--) { auto_reverse_fun_lst(i); } } } 这里隐含了一些状态机的想法，其实如果直接用状态机的框架可能会更好一点。这里的逻辑还是有一点绕。</description>
    </item>
    <item>
      <title>[project] 用于大负载转台驱动的伺服控制系统开发</title>
      <link>https://xym.work/blog/servo-system.html</link>
      <pubDate>Fri, 30 Aug 2024 10:00:00 +0800</pubDate>
      <guid>https://xym.work/blog/servo-system.html</guid>
      <description>0.简介 学校项目，用于大负载转台驱动的伺服控制系统开发。要求能实现高精度的转角控制以及对制定目标的跟踪控制。&#xA;使用电机为 PMSM，功率 40 kW，$ U_{IN} = 396 $ ，$ I_{o(eff)} = 73 A $，极对数 4。&#xA;实验室有一套祖传的电机控制板和代码，使用了 DSP + CPLD 的方案。芯片型号&#xA;DSP ：TMS320F28335 CPLD ：AG256SL100 此外还有一个配套的 LabView 的上位机，用来调整控制参数。也即核心控制算法上面，没有什么我需要去实现的，拿来先用。我只需要实现功率部分，然后调试硬件，最后调试控制参数。&#xA;这个项目对我来说算是个硬件设计项目。&#xA;1.PMSM 控制原理与方法 TMS320F28335 这个芯片常用来做电机控制，我看的一些拆车视频中，比亚迪秦、特斯拉 model 3 的电机驱动器用的就是这个型号的芯片。ST 也有专门用来做电机控制的芯片，有些一体化电机用的是 STM32 的芯片，还有好多开源的电机控制学习板也是这款芯片。&#xA;这里简略的介绍下 PMSM 的 FOC 控制算法&#xA;FOC 的核心想法是将定子三相电流通过坐标变换到定子同步旋转坐标系，分解为励磁电流和转矩电流。由于使用的是 PMSM，转子为永磁体，故使用了 $ i_d^* = 0 $ 的控制策略。经过坐标变换后，PMSM 的控制方式就和直流电机类似，励磁电流和转矩电流解耦分别进行控制。&#xA;SVPWM 则是一种发波方法，能提高母线电压的利用率，其本质也是一种三次谐波注入的方式，其更容易使用微控制器实现。&#xA;更细节的方法上的内容可以参考我的电机控制学习笔记。&#xA;2.功率部分设计 方法是这么个方法，从实现上来讲，MCU 需要的需要采集三相电流，转子位置，输出的 PWM 信号需要驱动功率模块。&#xA;一般的，低压部分和高压功率部分，低压部分实现纯逻辑的东西，高压功率部分即驱动板，完成信号的变换、隔离、功率输出。&#xA;此外实际的电机控制还需要考虑保护，比如过压、欠压、过流等功能。这些事情软件也可以做，但实际的电机控制一般都会用硬件实现以更快的实现保护，因此加了一个 FPGA ，在遇到硬件保护触发时，直接切断 PWM 输出，然后向微控制器发送错误代码。&#xA;STM32 的电机开发套件里给了更详细的图。</description>
    </item>
    <item>
      <title>[project] 2023 年电子设计竞赛：运动控制与目标追踪系统的设计</title>
      <link>https://xym.work/blog/laser-track.html</link>
      <pubDate>Thu, 29 Aug 2024 23:30:30 +0800</pubDate>
      <guid>https://xym.work/blog/laser-track.html</guid>
      <description>源码仓库 效果演示&#xA;0.简介 来源于 2023 年大学生电子设计竞赛的题目。我的导师正好是电赛的指导老师，我参加过2019年电赛，然后就帮忙一起指导一下。我主要出设计方案，完成控制算法可行性验证，主要是 webots 仿真和实际调试。&#xA;2023 的赛题：设计制作一个运动目标控制与自动追踪系统。&#xA;需要做两套系统，两套系统之间无通信&#xA;位置控制系统，红色激光模拟目标运动，激光点画出指定的矩形 自动追踪系统，绿色激光用来指示，绿色激光点跟踪红色激光运动 红色激光笔发射的光斑用来模拟运动目标，光斑落在正前方距离 $ 1 \text{m} $ 处的白色屏幕上，光斑直径 $ \le 1 \text{cm} $。红色光斑位置控制系统控制光斑能在屏幕范围内任意移动。绿色激光笔发射的光斑由绿色光斑位置系统控制，用于自动追踪屏幕上的红色光斑，指示目标的自动追踪效果。$ \le 1 \text{cm} $。&#xA;绿色激光笔放置线段如图 $ 1(b) $ 所示，该线段与屏幕平行，位于红色激光笔两侧，距红色激光笔距离大于 $ 0.4 \text{m} $ 、小于 $ 1 \text{m} $。绿色激光笔在两个放置线段上任意放置。&#xA;屏幕为白色，有效面积大于 $ 0.6 \times 0.6 \text{m}^2 $。用铅笔在屏幕中心画出一个边长 $ 0.5 \text{m} $ 的正方形，标识屏幕的边线；所画的正方形的中心为原点，用铅笔画出原点位置，所用铅笔痕迹宽 $ \le 1 \text{cm} $。&#xA;自动追踪系统只在完成提高题时需要。&#xA;1.赛题分析与方案设计 根据题目，有这几个比较重要的需要实现的功能&#xA;1.红色激光点能做一个固定大小的矩形运动 2.黑色胶带贴一个矩形框，红色激光点可以沿着黑框运行 3.绿色激光点追踪红色激光点运行 第 1 点，基础题的要求，激光点可以跟着铅笔线画一个方框。可以肯定的是铅笔线肯定不是用来做图像识别的，而且位置控制系统和屏幕的摆放都有严格的距离要求，那么在红激光点的位置上不需要做闭环控制，根据几何参数做计算，找到屏幕坐标系中点的位置和云台两个电机转角的关系，直接开环运动即可。需要在硬件上下点功夫，精度严重依赖几何参数，可以直接做一个架子，云台和屏幕都固定死了，😂，这种应试的项目不要不违反要求都是能做的。此功能要实现的代码的功能&#xA;实现指定两点之间的直线运动 第 2 点，黑胶带显然是要做视觉识别的，矩形运动比较关键的位置是 4 个顶点。有了 4 个点其实就可以计算出矩形边上所有的点了。这个目标的思路，一个也是纯开环控制，和功能 1 一样 ，有了四个点以后，有没有黑框就不重要了。</description>
    </item>
    <item>
      <title>[project] 搭载于密闭环境检测无人机的环境数据采集与上报模块软件开发</title>
      <link>https://xym.work/blog/data-collector-rt.html</link>
      <pubDate>Wed, 28 Aug 2024 13:00:00 +0800</pubDate>
      <guid>https://xym.work/blog/data-collector-rt.html</guid>
      <description>0. 介绍 这是一个物联网项目，合作公司的主要业务是使用无人机进行密闭环境的无人检测，如船舶、大型锅炉、化工厂储罐等内部观察检测。该项目需要开发一套用于密闭环境近观检测的无人机系统，涵盖硬件设计、软件开发与系统集成。该系统由无人机端、地面监控端和数据传输与系留供电模块组成，专门用于密闭空间内的精细检测任务。无人机端搭载高清相机、飞控系统，以及一个基于 STM32F407 的环境数据采集与上报模块。该模块通过外挂的 W5500 芯片与无人机局域网内的机载工控机进行通信，采用 UDP 协议实现数据传输。&#xA;我负责环境数据采集与上报模块的所有软件功能开发。&#xA;源码仓库&#xA;1. 硬件方案 此项目我不负责硬件设计部分，但这里也简单介绍一下硬件方案。&#xA;主控芯片：STM32F407VET6 网络芯片：W5500 W5500(datasheet)是一款全硬件 TCP/IP 协议栈以太网控制器，内部集成了以太网数据链路层（MAC）和以太网物理层（PHY），内嵌的 8 个独立硬件 Socket 可以进行 8 路独立通信。使用标准 4 线 SPI 接口与主机进行通信。&#xA;传感器部分&#xA;1 个高精度温度传感器 MCP9808 IIC 接口 2 个电化学可燃气体浓度传感器 UART 接口 3 个 ToF 距离传感器 IIC 接口 此外，还有共 20 个 GPIO 用来控制灯光、电源的开关。&#xA;激光测距传感器 可燃气体浓度传感器 高精度温度传感器 2. 软件开发情况总体介绍 RTOS 选择: rt-thread 在软件开发上，考虑到此模块外接的设备较多并且需要网络协议栈，裸机开发可能会比较棘手，因此基于 RTOS 完成开发。&#xA;比较常用的 RTOS 是 freeRTOS ，我学习的第一个是 rt-thread，rtt 除了实时内核，对设备驱动也做了抽象，有更易调用的方法和软件包，因此基于 rt-thread 开发该模块的软件。我看过一些 freeRTOS 项目的源码，外设驱动大多是和裸机操作一样基于 HAL 库来完成。rtt 设计一套统一的 api ，和 linux 类似使用 open close read write 来操作设备，此外我更喜欢 rtt 源码风格，其和 linux 风格类似使用全小写+_的方式。</description>
    </item>
    <item>
      <title>[post] 静态网站搭建中有关计算机网络相关的内容</title>
      <link>https://xym.work/blog/hugowebsite.html</link>
      <pubDate>Tue, 20 Aug 2024 13:00:00 +0800</pubDate>
      <guid>https://xym.work/blog/hugowebsite.html</guid>
      <description>0. 介绍 需求 1：我需要有个个人网站 hugo 、github pages 需求 2：我需要在局域网中开发和调试 端口转发，NAT 需求 3：我想要更快的访问速度 云服务器部署网页，nginx 需求 4：我想在外网访问内网的机器开发和调试 内网穿透，frp 需求 5: 我还想要更好的体验 软路由、定时任务。问问 chatgpt 1. hogo 生成静态页面 在 ubuntu 环境下开发，ubuntu 安装于虚拟机中，采用桥接网卡方式上网。IP 10.0.0.22&#xA;使用了 terminal-hugo-theme 主题，按照 README 中的说明，在本地生成静态页面并启动一个本地的网页服务器，&#xA;hugo server --buildDrafts --disableFastRender --gc --ignoreCache --noHTTPCache --forceSyncStatic --verbose -w 指令的参数&#xA;--buildDrafts: 生成静态页面时为草稿的内容 --disableFastRender: 禁用快速渲染(只会重新生成发生变化的部分)，确保在每次更改时全部重新生成 --gc: 垃圾回收，清理未使用的文件 --ignoreCache: 强制忽略缓存并重新构建所有文件，确保生成的时最新的 --noHTTPCache: 禁用 HTTP 缓存，强制浏览器从服务器加载站点，确保从浏览器看的到是最新的 --forceSyncStatic: 强制同步静态文件（例如图片、CSS、JS），即使 Hugo 认为它们没有更改。确保所有静态资源都是最新的 --verbose: 输出更多信息 -w: 是 --watch 的缩写，监视文件系统的更改，并在文件修改时自动重新构建站点 hugo 的本地网页服务器监听 1313 端口，生成后，在 ubuntu 的浏览器中访问 http://127.</description>
    </item>
    <item>
      <title>构建最小 Linux 系统</title>
      <link>https://xym.work/blog/minimal-linux.html</link>
      <pubDate>Mon, 17 Jul 2023 19:01:48 +0530</pubDate>
      <guid>https://xym.work/blog/minimal-linux.html</guid>
      <description>Linux 世界中的应用程序 (从零开始构建 “最小” Linux) [南京大学2023操作系统-P16] (蒋炎岩) 16. Linux 操作系统 为了努力的理解操作系统，学习过程中的一个想法：能不能控制电脑启动后加载的第一个程序。&#xA;事实上，电脑启动到出现桌面，这个过程并不简单。先不讨论 bootloader 阶段，只说 linux kernel，即一个想法：控制 kernel 启动后加载的第一个程序。kernel 启动后加载的程序都放在存储介质里，即存储介质里的东西不需要那么多，目录足够简单。&#xA;linux 一般仅指 kernel，根目录下的所有东西为根文件系统。构建最小 Linux 系统的完整说法：构建根文件系统最小的linux系统。&#xA;如果查看 pstree ，可以看到进程之间的关系&#xA;QEMU 下模拟 希望在给定的 linux 内核初始化完成后，直接执行我自己编写的静态链接的 init 二进制文件，我该怎么做。&#xA;查看手册得知，kernel init 函数中，会尝试按顺序执行一些东西&#xA;if (!try_to_run_init_process(&amp;#34;/sbin/init&amp;#34;) || !try_to_run_init_process(&amp;#34;/etc/init&amp;#34;) || !try_to_run_init_process(&amp;#34;/bin/init&amp;#34;) || !try_to_run_init_process(&amp;#34;/bin/sh&amp;#34;)) return 0; 这便是启动的第一个进程，如果一个都没找到，那么就会 kernel panic。&#xA;QEMU 中可以用参数指定启动的系统镜像，从而不需要考虑 bootloader 的事情，因此先在 x86 平台做这个事情。为此我们需要准备 内核镜像与根文件系统里的东西。&#xA;内核镜像可拿一个现成的来用 /boot/vmlinuz ，&#xA;按照 linux 约定的方式，把我们自己的可执行文件放到 bin 里&#xA;准备好了所有东西，把这些东西打包起来&#xA;cd rootfs find .</description>
    </item>
    <item>
      <title>C 语言实现 PID 控制算法</title>
      <link>https://xym.work/blog/pid-in-c.html</link>
      <pubDate>Fri, 13 Jan 2023 19:01:48 +0530</pubDate>
      <guid>https://xym.work/blog/pid-in-c.html</guid>
      <description>实时控制在嵌入式平台上完成，ARM 内核的 MCU 主流开发语言还是 C 语言，花点时间去实现一个通用的 PID 控制器是值得的。这里使用 webots 仿真一个平衡车来验证控制器实现的正确性。&#xA;平衡车和倒立摆的原理基本一致，可以参考另一个倒立摆 MATLAB 仿真的文章。&#xA;PID 离散表达 一个使用 PID 控制器的控制系统结构如图&#xA;其中 PID 控制器串在前向通路上，所以这是一个串联校正装置。PID 控制器内部的结构如下图&#xA;数学表达式为&#xA;$$ u(t) = K_p e(t) + K_i \int e(t) \text{d}t + K_p \frac{\text{d}e(t)}{\text{d}t} $$&#xA;这是个连续函数的表达式。计算机程序是离散时刻运行的，我们还需要得到离散化的表达式。也很容易，离散时间定义域里的求和就是连续时间的积分，离散的差分就是连续的微分。则离散时间定义域下 PID 控制器的表达式为&#xA;$$ u(k) = K_p e(k) + K_i \sum e(k) + K_p (e(k) - e(k-1)) \tag{1} $$&#xA;式(1)就是位置式PID。&#xA;相邻两次控制输出的增量为：&#xA;$$ \begin{array}{rcl} \Delta u(k) &amp;amp;= &amp;amp;u(k) - u(k-1) \ &amp;amp;=&amp;amp; K_p [e(k) - e(k-1) ] + K_i e(k) + K_d [e(k) - 2e(k-1) + e(k-2)] \ \ u(k) &amp;amp;=&amp;amp; u(k-1) + \Delta u(k) \ \end{array}\tag{2} $$</description>
    </item>
    <item>
      <title>计算机系统实践：Cheat Engine开发游戏修改器</title>
      <link>https://xym.work/blog/cheat-engine.html</link>
      <pubDate>Fri, 28 Jan 2022 19:01:48 +0530</pubDate>
      <guid>https://xym.work/blog/cheat-engine.html</guid>
      <description>（待完善）&#xA;官网介绍：Cheat Engine是一个主要用于修改游戏和应用程序的开发环境。&#xA;也就是说CE是一个和游戏修改器差不多的东西，改物品栏数值、锁血啥的，但是普通游戏修改器是个现成的程序一键操作完成，CE是个开发环境，功能相当强大。&#xA;CE最终目的并不是去改游戏，更重要的，是对计算机组成原理、微机原理、汇编、程序与数据理论知识的应用。在游戏修改器开发过程中计算机知识的实践，这种快乐程度要比在8086虚拟环境上多得多。&#xA;既然是游戏修改，就涉及到一个游戏道德甚至是法律问题，对于单人游戏，个人认为怎么搞随便，至于多人游戏，有反作弊机制，更严重的“破坏计算机信息系统罪”适用于制作外挂并传播这一行为。&#xA;这个工作涉及到CPU工作原理、内存、x86指令集，理论知识，CE使用方法、工作流程，数据修改与指令修改。&#xA;GitHub: Cheat Engine. A development environment focused on modding&#xA;Cheat Engine wiki&#xA;游戏的运行与CE原理 CPU是逻辑电路，进行简单的逻辑运算，游戏执行最终落实到CPU上是一系列指令。因此最终CPU运行的就是一条一条指令。&#xA;CPU工作很呆板，就是执行一条条指令，通过指令操作数据对数据进行读和写。&#xA;比如游戏背包里的物品个数，这就是数据，物品数量变化，CPU进行加减就可以。&#xA;事实上，指令和数据是编码的形式存在在电脑内部的。&#xA;如果只有这么一串01，理论上讲是无法区分到底是指令还是数据，CPU是靠上下文来判断的。电脑开机后CPU读到的第一个字节必然是指令，每条指令里会指示后面的编码是指令还是数据。所以，改数据和改指令从编码层次上来看是一样的。&#xA;如果要修改编码，我们就得知道这些编码保存在哪里，肯定不是CPU，事实上存在内存里，指令和数据都是从内存里面取出来的，所以我们改程序实际上是在改内存里的编码。&#xA;CE的工作原理就是监控任意一个应用程序使用的全部内存，并且可以随意修改编码。这样一来，理论上就可以对游戏进行任何操作。&#xA;比如说，找到了血量的存储位置，并冻结数据，这就锁血了。或者找到“减”指令，换成空指令，或者直接变成加，这就挨打了还加血。&#xA;综上，CE修改的思路也就是很简单两步：&#xA;1.找到感兴趣的编码在内存里的位置 2.修改编码 数据 指令 数据和指令没有区别，都是编码&#xA;计算机编码是二进制的，但是为了表达方便，用字节为单位使用16进制表示。&#xA;数据修改 基本操作 最简单的用法，根据精确的数值行为定位内存地址。多次筛选后，就可以找到生命值所在的内存地址，可以直接修改数值。&#xA;如果不知道具体数值，比如说只有个血条，那么使用未知初值的选项进行第一次搜索，然后使用数值行为，比如说正在减少或者减少的具体值这些特征来筛选对应的内存地址。&#xA;数据类型也是个需要关注的问题。&#xA;内存数据结构 单次修改保存了变量列表，下次打开以后，发现这个表已经变了。如果要反复使用该如何操作呢？&#xA;内存从下往上看，&#xA;指令|数据（全局、堆、栈）&#xA;堆是随便分配加回收的，栈倒是连续的，但是栈的其实位置随机的。&#xA;因此指令的位置是固定的，堆和栈里的数据位置不固定，因此重新运行的游戏就不知道了。&#xA;但是游戏自己肯定是知道堆栈地址在哪里的。通过指针指向堆栈数据。&#xA;那么我们也可以和游戏一样，通过源头指针一路找到血量。&#xA;指针追溯 追溯到全局变量段就可以了。&#xA;手动追溯，对数据结构的深入理解。&#xA;查找到具体数值所在的内存后，可以直接查找这个内存地址，查看是什么指令在访问这个内存，就可以找到这个地址的指针。直接使用指针来操作数据，在每次游戏重启后，同样也是可以用的。&#xA;要注意的是，有时候数据定义在一个结构体内（或者是一个类），寻址方式是基地址+偏移地址，因此需要计算出偏移地址。可以在手动添加指针的时候设置偏移地址。&#xA;实际游戏这么一级指针还是有点简单了，更多情况下是好多级指针，在上层程序设计的时候有数据的继承，在汇编层次上就是多次指针跳转。每次跳转实际上是跳转到结构体的基地址了，因此要注意每一次跳转的偏移地址。追溯到绿色名称就可以停下了，这一段是指令段。&#xA;手动追溯指针需要非常了解数据结构以及编译后的数据存储方式。自动追溯会容易一点，首先找到血量所在的地址，使用指针扫描，然后瑞出游戏重新进入。再次找到血量的地址，找出相关指针，取个交集。大概就是这么个思路，因为偏移量总是固定的，交叉比对出我们需要的指针。&#xA;最后，如果数据的源头也不在全局变量里，那这修改数据就行不通了，然而指令肯定是在固定位置的。这时候就得使用改指令的方法了。&#xA;指令修改 x86指令集 指令集和机器码差不多（真指令），可以等价起来。机器码给给机器读，汇编给人看更容易一点。&#xA;CPU里的寄存器数量有限，速度快数量少。x86对应的寄存器只有16个，除了寄存器，还需要了解一下寻址方式和常用的指令。&#xA;MOV ECX, [RSI + 07E0]&#xA;机器码的格式，指令编码的长度是不固定的，简单知道编码格式&#xA;操作码 数据1 数据2&#xA;指令修改思路 这也是个去哪里干什么的事情。</description>
    </item>
    <item>
      <title>三相异步电动机矢量控制 MATLAB 仿真</title>
      <link>https://xym.work/blog/motor-foc.html</link>
      <pubDate>Tue, 18 Jan 2022 19:01:48 +0530</pubDate>
      <guid>https://xym.work/blog/motor-foc.html</guid>
      <description>矢量控制或者FOC控制近些年逐渐走进日常消费电器了，在一些洗衣机，电动玩具的广告里甚至可以直接看到这个词，我觉得这对消费者来说要求还是有点高了😂😂。&#xA;FOC控制大规模的商业应用也能看出这是一种相当成熟的电机控制方法了，这里做一个异步电机的矢量控制仿真总结。&#xA;矢量控制基本思想 矢量控制这个名字的由来是控制方法里有坐标变换（矢量变换），FOC控制的全名是按照转子磁链定向控制，其含义是在坐标变换后把旋转坐标系的d轴方向固定在转子磁链方向。往往伴随的还有SVPWM这个词，这是一种调制方法，可以提高电压利用率，矢量控制不一定必须用到SVPWM的调制方法。&#xA;矢量控制系统比较复杂，整个系统由很多部分或者叫模块构成，每个模块又有不止一种方法实现，但是使用不同方法的模块实现的功能是一样的。因此比较先进的控制方法也是在整个老的系统结构上去优化一个模块。一个典型的就是无传感器控制，实际上是状态观测器用作传感器。&#xA;首先梳理一下矢量控制的基本思想：&#xA;对于他励式直流电动机来说，接线端子4个，两根为励磁绕组引出，两根电枢绕组引出，磁通和电枢电流可以分开单独控制，磁通恒定后电磁转矩就只和电枢电流有关了。&#xA;对于三相异步交流电机来说，接线端子有6个，如果是接成了Y型不引出中心线，那么端子有3个，这三根线进去的电流有一部分产生磁通，一部分产生电磁转矩，混叠在一起。这也是交流电机控制复杂的原因。&#xA;矢量控制的基本方法是使用坐标变换（矢量变换），核心思路就是把混叠在一起励磁电流和电枢电流分开来，单独控制励磁电流恒定，这样转矩就可以单独由电枢电流控制，和直流电机一样了。坐标变换只是我们看待问题的视角变了，实际电机物理系统的磁动势和功率是个客观量，因此变换原则是保持磁动势不变。分解出励磁电流和电枢电流后，按照给定值加以控制后，还需要再合成三相电流的给定值，让实际电流跟随三相给定电流。这就是基本的矢量控制思路。&#xA;CHBPWM调制矢量控制结构图 根据上面的描述，关注这几个细节：&#xA;如何进行坐标变化。参考系的选取，怎么变才能达到分解电流为励磁分量和转矩分量。&#xA;转子磁链定向问题。在坐标变换中有个坐标系是和转子磁链一同旋转的，因此我们需要知道转子磁链的角度，在对励磁电流进行控制时，也需要知道磁链大小，因此转子磁链计算是要解决的一个问题。&#xA;PWM调制方式。电子电子变压变频器都是要去使用脉冲宽度调制的。在使用PWM时有个小问题，日常家用电220V，如果使用SPWM去产生220V的交流电，使用220V直流电做不到，日常讲的220V交流电是有效值，其标准的数学表达式为$$ u(t) = 220\sqrt{2}\sin(\omega t + \varphi) $$，因此如果使用SPWM调制方法，需要的直流电源为$$ 220\sqrt{2} \approx 311 \mathrm{V} $$，如果要产生有效值380电压的交流电，需要的直流电源约为537V。这就感觉很不舒服，因此如何用电压更小的直流电源产生有效值更大交流电，也是个需要解决的问题。&#xA;如果这几个细节都清楚了，那么矢量控制的核心原理及方法大概也就搞明白了。&#xA;在整个矢量控制细节结构上，还可以进行一些优化改进，比如：&#xA;进行转矩控制提高动态。这是矢量控制里的转矩控制，区别另一种思想直接转矩控制。虽然励磁电流和电枢电流解耦了，但是在控制励磁电流跟随给定的时候还是会有波动，因此为了更好的动态性能，在转矩波形影响转速前就对其进行控制，有两个常用的方法。&#xA;无传感器控制。转速控制需要转速值，一些磁链计算方法也要转速值，现在转速传感器也不想要了，使用算法充当转速传感器，比如状态观测器等一些转子位置估计方法，这也是近些年电机控制的一个新话题。&#xA;以上这些点，后面的仿真都会出现。&#xA;接下来就要开始做仿真了。&#xA;仿真电机参数 被控对象为一台三相笼型异步电动机(Triple-phase asynchronous motor)，铭牌参数：&#xA;额定功率$$ P_N = 3\mathrm{kW} $$ 额定电压$$ U_N = 380 \mathrm{V} $$ 额定电流$$ I_N = 6.9 \mathrm{A} $$ 额定转速$$ n_N = 1400 \mathrm{r/min} $$ 额定频率$$ f_N = 50 \mathrm{Hz} $$ 极对数$$ n_p = 2 $$ 定子绕组$$ \mathrm{Y} $$联结 由实验测得的数据：</description>
    </item>
    <item>
      <title>学git和Github——项目管理与合作开发</title>
      <link>https://xym.work/blog/git.html</link>
      <pubDate>Sun, 09 Jan 2022 19:01:48 +0530</pubDate>
      <guid>https://xym.work/blog/git.html</guid>
      <description>github 和 git GUI git CLI https://learngitbranching.js.org/?locale=zh_CN&#xA;git 和 github 的连接 前言 在本科参加比赛的时候，我和我的队友们一共3个人，每个比赛也都算是一个小项目，使用C语言开发单片机，当时还没有项目版本管理的概念。合作方式是基于压缩包与U盘的，分支靠文件夹重命名，合并就是复制替换。&#xA;在搞毕业设计的时候，也有一种类似的文档版本管理方式：&#xA;这大概就是版本管理的初级设想吧。&#xA;git就是这样一个工具，可以实现本地的、细致到字符级别的版本管理。&#xA;比如git记录了我对一个文档的第176行指令的修改。&#xA;Github是另一个东西，云端，和本地照片备份到云端是一个性质。也就是说如果写代码只是自己一个人写着玩玩，也不需要合作，也不想给别人看，只有个git就可以实现版本管理了。同步到云端Github会让所有人看到具体内容，有了更多的社交属性在里面。&#xA;从Github下载、上传到Github 一个软件的用法，我认为还是思路最重要，逐步操作放到最后面，理解了思路以后，再看的逐步教程也就知道自己是在干嘛了。看逐步教程容易被淹没在指令里😂😂，我觉得对一个纯新人不是很友好。&#xA;下面出现的一些措辞不严谨，只是为了更好理解，所以用了日常使用软件的一些说法。在文章最后会全部替换为准确说法，并与指令对应起来。&#xA;首先装软件，安装好git和gitahead，然后要有个Github的账号。可以认为gitahead是我们用来上传下载的工具。&#xA;先尝试从Github（云端）下载一些东西下来。比如说我在云端有个代码库叫learning，首先打开gitahead，需要登录自己的GitHub账号。中间巨大的Add Github account，也可以点击左下角的“+”也有这个选项。&#xA;弹出窗口的Username就是Github的用户ID，但是密码不是登陆密码，这个类似于邮箱二次验证。去Github网页端进入设置页面，在Developer settings里，找到Personal access tokens，生成一个新的长密码就行，下面所有的框全选上，可以选择长期有效。用新生成的密码就可以登录gitahead了。&#xA;登陆后，要在tools-options里填上自己的邮箱地址。&#xA;这时候左列出现了云端的东西，可以直接下载。这就有网盘的感觉了，还挺好使。&#xA;现在要往learning这个云端仓库上传一个文件试试，去刚下载下来的这个learning里面，新建一个新建文本文档.txt，也可以打开随便写点东西保存后来上传。&#xA;上传稍稍有点不一样，要多操作几步（后面会拆开来说原因），左边选中Uncommitted changes，上边的框框点击Stage All，然后点击Commit，最后工具栏里会多出一个红色的1，鼠标移过去显示“Push”，点一下就完成上传了。&#xA;合理猜测Push左边的Pull是不是可以下载。&#xA;虽然这个东西上传有点麻烦，但是也不是很麻烦。&#xA;版本管理 其实在上面上传的时候已经有点版本管理的感觉了。这个Push更准确的含义应该是向云端同步，那么pull的含义是云端向本地同步。&#xA;前面说过，git是本地版本管理软件，也就是说Push操作已经是在本地管理完了，要同步到云端公开鉴赏了。&#xA;那么显然Stage All，Commit就是在本地进行版本管理。Commit是提交文件修改到本地，Stage All是暂存修改。&#xA;可以随便改改提交试试，这种全新的版本管理还是很不错的。&#xA;左边有条线串起了每个版本，这根线串起来的就是一个分支。目前仅有一个分支。&#xA;回退也很简单，随便挑一个版本，右击，选reset-hard是最简单粗暴的方式。至于各个方式的区别，不同方式略有区别。可以多试试一些操作，软件这个东西，玩不坏的，不行就重启试试。再不济删掉重来。&#xA;分支操作 一个分支够了。后面有时间再写吧。&#xA;其实熟悉本地版本管理和远程同步，一个分支操作熟悉了以后，用图形界面客户端跟着感觉按按，也能按出来。这也是使用gitGUI的一个优点吧。&#xA;贡献代码 很多时候，我们不止想单兵作战。还想邀请亲朋好友一起写代码，如果离得近还科技基于U盘进行代码分发，基于压缩包进行版本管理。&#xA;但是现在有git做版本管理了，也想用起来。一个思路是大家有一个公共仓库，每个人都可以向提交自己的仓库一样提交文件公共仓库。这就是Github里organization的作用。&#xA;对于一些大开源项目，这样不合适，不能随便一个人都随便提交，任意修改，总会有人想搞破坏。所以还要有一种需要审核的提交文件的方式。&#xA;比如说如果我最近看到一个挺不错的电气电子控制的课程资料项目https://github.com/Control-and-Engineering/course-materials-backup，正好手上有一份资料可以贡献一下，这个项目仓库属于一个叫 Control-and-Engineering的人。显然这不是属于我的仓库，不会在gitahead左侧出现，我无法直接上传到这个仓库里。&#xA;首先得让这个仓库属于我，Github给出的方法是Fork一份，就像用U盘复制一份一样，从 Control-and-Engineering的云端空间复制到我的云端空间。&#xA;这时候我的云端就有一个一模一样的备份了，这是属于我的，所以我可以任意修改。改好以后，同步到我的云端，这时候其实再从我的云端“复制”到 Control-and-Engineering的云端就好了。这就是页面上的Contribute，可以看到里面的按钮是Open pull request这是一种需要请求的贡献方式，也更广泛的使用。&#xA;上传大文件(&amp;gt;100MB) 安装git-lfs，然后点击githaead里的工具栏Submodule，Configure Submodules，选最后一个LFS。然后初始化。&#xA;git lfs install #安装大文件上传应用 git lfs track &amp;#34;*.</description>
    </item>
    <item>
      <title>PID控制器、串联校正装置理论分析和性能对比</title>
      <link>https://xym.work/blog/pid-controller.html</link>
      <pubDate>Fri, 19 Nov 2021 19:01:48 +0530</pubDate>
      <guid>https://xym.work/blog/pid-controller.html</guid>
      <description>经典控制理论在频域或者复频域分析系统的性能。&#xA;复频域s平面，闭环极点决定了系统稳不稳，闭环零点影响系统性能&#xA;频域则使用相位裕度来衡量系统性能，更简洁有力，系统阶数越高，频域方法使用起来越优越。&#xA;PID控制器从零极点的角度考虑，引入了新的零点极点，从频域考虑，则是一类特殊的串联校正装置，所以先总结一些零极点定性的的结论，然后&#xA;零点极点对系统的影响 闭环极点，模态，系统响应由模态叠加。负实根，模态收敛，共轭虚根，处理一下是三角函数，即震动，实部为包络线，实部为负，震动收敛。&#xA;更多情况下并不直接讨论闭环极点，而是从开环出发分析系统的闭环性能。&#xA;比如复频域里的根轨迹法，通过开环零极点位置，来判断参数调整对闭环极点位置的影响。&#xA;频域里，通过开环对数幅频、对数相频图，判断闭环系统的稳定性、稳定程度。&#xA;各类控制器对比 PID&#xA;比例控制器&#xA;$$ G_c(s) = K $$&#xA;PI控制&#xA;$$ G_c(s) = K_P + K_I\frac{1}{s} = \frac{K_Ps+K_I}{s} $$&#xA;$$ G_{PI}(s) = K \frac{Ts+1}{s} $$&#xA;PD控制&#xA;$$ G_c(s) = K_P + K_D \cdot s $$&#xA;$$ G_{PD}(s) = K (Ts+1) $$&#xA;PID控制&#xA;$$ G_c(s) = K_P + K_I \cdot \frac{1}{s} + K_D \cdot s = \frac{ K_P\cdot s + K_I + K_D \cdot s^2 }{s} $$</description>
    </item>
    <item>
      <title>二维向量场可视化工具与相平面图</title>
      <link>https://xym.work/blog/field-play.html</link>
      <pubDate>Sun, 31 Oct 2021 19:01:48 +0530</pubDate>
      <guid>https://xym.work/blog/field-play.html</guid>
      <description>1.二维向量场 这篇文章介绍了一个平面向量场可视化的网页工具：fieldpaly&#xA;这里只是介绍了系统相平面可视化实现的代码，给出了我定义的系统代码标准型，如果对相平面、非线性系统、状态空间、微分方程解的性质等控制的理论内容感兴趣，可以参考我的笔记：相平面法-工程中的数学&#xA;从纯数学的角度来讲，这是一个画二维向量场的网站。二维向量场的数学表达：&#xA;$$ \boldsymbol{A} = (P,Q) = P(x,y) \cdot \boldsymbol{i} + Q(x,y) \cdot \boldsymbol{j} $$&#xA;平面向量场$$ \boldsymbol{A} $$与位置相关，一般纸面上的表达方式是平面上每个点都有一个带箭头的向量。&#xA;可视化的表达方式更加直观，通过粒子的运动就能反映向量场的情况。&#xA;按照“速度矢量和位置相关”的思路，这个可视化网页提供了一个接口，入口参数为位置，返回参数为该点速度，函数体内可以自己实现数学关系。&#xA;vec2 get_velocity(vec2 p) { vec2 v = vec2(0., 0.); /* p与v的数学关系实现 */ return v; } 举个例子，可视化一个点电荷形成的电场。&#xA;在原点放置一点电荷带电量为$$ -q $$，试探电荷带电量$$ +q^* $$，其所在位置为$$ \vec r $$&#xA;试探电荷受到的力为&#xA;$$ \vec F = -k\frac{qq^*}{r^2}\cdot\vec {r^°} $$&#xA;则电场强度为&#xA;$$ \vec E = \frac{\vec F}{q^*} = -k\frac{q}{r^2}\cdot\vec {r^°} $$&#xA;取$$ kq = 1 $$，那么这个电场的表达式为</description>
    </item>
    <item>
      <title>基于Simscape的倒立摆控制算法仿真</title>
      <link>https://xym.work/blog/simscape.html</link>
      <pubDate>Thu, 19 Aug 2021 19:01:48 +0530</pubDate>
      <guid>https://xym.work/blog/simscape.html</guid>
      <description>各种现代控制方法层出不穷，但是PID万古长青。纵使你理论发展又快又好，工业上还是PID占据了大半江山。没事整整PID还是挺有用的。&#xA;仿真对象 这里用倒立摆作为仿真对象，对各种花式PID的控制效果进行比较。通过对倒立摆这一典型的非线性系统的控制，可以检验各种PID控制方法是否有较强的处理非线性和不稳定性问题的能力。&#xA;常用的机器人仿真工具有Gazebo、Webots、MATLAB等，这里使用到的是MATLAB中的Simscape Multibody模块，MATLAB版本为2019b。Simscape 是 Simulink 的一个模块，而 Simscape Multibody 又是 Simscape 的一个模块。这个模块是一个多体机构仿真环境，提供了几何体、关节、约束、施力单元以及传感器等大量的组件，这使得在MATLAB中搭建一个机构仿真框图十分容易，同时模块集成了3D可视化组件，这使得仿真结果更为直观。&#xA;搭建一个倒立摆的模型，&#xA;设置好各种物理参数，输出4个传感器数据作为反馈参数（不一定都要用到，先留着），打包成一个subsystem。直接启动仿真，可以看到在没有外力所用下，只要有轻微干扰，倒立摆就直接倒了。&#xA;然后把摆杆角度作为反馈，直立状态作为给定计算得到偏差，把摆杆初始角度调成左偏30°，然后随便整两个PD参数，基本上就能立起来了。&#xA;系统结构是下面这个样子，这个结构就代表了很大一类的简单控制系统，比如温度控制、液位控制等。&#xA;控制效果&#xA;当然也可以加上位置控制，看起来更像比较厉害的控制理论。要做的就是在角度控制的基础上串上个位置控制&#xA;对于一个阶跃信号的控制效果&#xA;由此可以看出，PID是个好东西。倒立摆其实并没这么简单，是个挺复杂的小东西，但是在使用PID的时候，完全没考虑其数学模型的问题，就直接让他立了起来，甚至效果还不错。PID让即使是不懂控制控制理论的人也可以随便试几个参数达到这个效果，所以PID的广泛应用也是情理之中的。当然网上讲PID的直观理解的人很多，开车的、倒水的、烧火炉的故事都有人讲过，这些故事对PID的直观理解也有很大帮助。当然PID的在数学上的作用机理没这么好理解，搞控制理论的人总是执着的用数学手段严格证明一个系统的稳定性，关于控制背后的数学原理，后面有空再写写。&#xA;再加点程序控制手段，用$\theta$和$\dot \theta$这两个参数模仿人把摆甩起来，然后偏差小到一定范围内切换角度+位置闭环控制，控制结构图如下图：&#xA;控制效果&#xA;这个启动控制看起来相当厉害，但是控制手段却是最没牌面的，坦率的讲没有用到任何控制算法，这只能叫控制方法，就是个开环盲甩，实际情况下抗干扰能力太差，随便什么参数变一下后果直接不可预测，当然这里启动不是重点，相关方法也有很多比如bangbang控制、能量反馈控制，这些都是有反馈即自动控制的核心思想在里面的。&#xA;到这里一切只是个开始，在比较早的年代，有用纯硬件搭的PID控制电路，随着嵌入式与微电子的发展，数字控制逐渐取代了模拟控制，越来越多的改进PID方法诞生了，这些改进的PID控制方法使得经久不衰的PID再次焕发了生机，这也是本文想学习仿真的东西。&#xA;理论分析 只试两个参数感觉还是差了点意思，毕竟不学控制理论的朋友稍微试试也能到这个效果，还是要理论分析一下才显得像是个学过理论的人。&#xA;理论分析的第一步就是把这个物理的东西先变成数学上的一个式子，俗称数学建模。众所周知，经典控制理论分析的是线性定常微分方程，这个倒立摆输入是力，把摆杆偏角认为是输出，那么正好凑凑能搞出的微分方程，这样就可以进一步分析了。&#xA;$$ F(t) = M \ddot{x}(t) + m [ \ddot{x}(t) + ] $$&#xA;然后工作点附近线性化一下，有了线性定常微分方程了：&#xA;$$ \left[ ml - J\left(\frac{M}{m} + 1\right) \right] \ddot\theta(t) + (M+m)g\theta = f(t)$$&#xA;然后呢，传递函数就有了，这时候，零极点、根轨迹、波特图各种分析手段都可以使用了，各种校正手段都可以用在这个微分方程上。&#xA;如果想更先进一点，可以使用状态空间来描述这个事情。&#xA;。。。。。 （有时间一定补充）&#xA;模糊控制 自适应模糊PID 状态反馈控制 二阶倒立摆状态反馈控制 二阶摆 模型&#xA;不加外力&#xA;并联PD，一般单入单出的控制，不能这么搞的，😂，这个东西不一样，本质上是状态反馈，用极点配置法求出6个反馈参数，所以看起来是并联PD，但是本质是状态反馈。&#xA;来个初始小偏差，看看效果&#xA;能立起来了。</description>
    </item>
    <item>
      <title>基于Github Pages的个人网站(1)——建站记录</title>
      <link>https://xym.work/blog/jekyll1.html</link>
      <pubDate>Thu, 29 Jul 2021 19:01:48 +0530</pubDate>
      <guid>https://xym.work/blog/jekyll1.html</guid>
      <description>1.搭主页之前 为什么我会想搭一个自己的网站呢？&#xA;首先是经验积累。把做过的东西像集卡游戏一样收集起来也是一件挺好玩的事情。其次内容洁癖，要对自己的内容有绝对的控制权，不允许有广告这种不可控内容出现在自己的页面上。&#xA;基于以上的想法，商业博客基本上就被排除掉了。一开始我用的是GitHub，.md文档可以在GitHub网页上直接展示，有一半博客的功能，而且页面相比CSDN之类的足够干净。&#xA;一个小项目总结 用了两天以后发现，在网页上只能显示文字和图片，就像上面这样。在本地的VS Code上可以通过插件实现latex公式，然而网页打开就是一串代码，当然截图插入也是个方法，最重要的是，图片大小不可控。在使用GitHub的这几天，我发现有许多人都有基于Github Pages的自己的主页，可以实现各种功能，这就正好和我的需求对上了，于是经过几天试验，有了目前这个网站。&#xA;2.整体设计思路 我的主页的内容按照下面这几个部分来设计的：&#xA;简历。突出一个个人特征。这部分是给别人看的，放在首页，如果有幸有人不小心点进了我的主页，那么不看也得看，无形之中推销自己。 传统的技术博客。类似于CSDN的中短文章，项目经历展示，开发经验积累，别人看，自己也看。 长篇幅的笔记。大节小节带数学公式，知识总结沉淀。这部分是给自己看的，顺便给别人看，当然由于内容过于臃肿我觉得进来的人几乎不会看的。 在个人简历中我会把这个网页放在一个突出位置，除了实体纸质简历，引导看我简历的人来到这个网页。进入主页直接就有个人联系方式以及社交账号，主页下拉是一个简单的个人介绍，此外还有一些项目经历和我更完整的工作技能点，详细的知识结构。对于一个陌生人来说，这是我最想让他们看到的东西。这个网站更像是个“大简历”，一个实时更新，全面展示的简历。对我感兴趣的人会点击导航栏里“关于我”查看我更详细的个人经历，对我的项目感兴趣的人会点击“我的项目”去看我的开发经验。对我知识结构感兴趣的人会点击“学习笔记”去看我的知识储备。&#xA;3.方案实现 3.1 GitHub Pages是什么 我的GitHub ID是@1xyMeng{:target=&amp;quot;_blank&amp;quot;}，新建一个名为1xyMeng.github.io{:target=&amp;quot;_blank&amp;quot;}的仓库，在仓库Setting选项卡里的GitHub Pages进行如下设置&#xA;这时候1xyMeng.github.io这个地址已经是一个可以访问的网站了。再新建一个随便什么名字的仓库，和上面一样的设置&#xA;这时候1xyMeng.github.io/learning也是一个可以访问的网站了，而且对比一下这两个地址，很有意思，找到一点感觉了。&#xA;这时候如果在1xyMeng.github.io仓库的README.md里面加一行&#xA;[点击跳转](https://1xyMeng.github.io/learning) 使用浏览器访问1xyMeng.github.io，可以看到多出来的一行内容，点一下果然会跳到learning页面。&#xA;以上就是我的网站的最基本的逻辑。把仓库里的内容变成一个可以访问的网页就是GitHub Pages帮我们办到的事情。&#xA;注1：修改了文件后，需要等几分钟，毕竟GitHub Pages帮我们办事情也是要花时间的，在仓库右侧Environments可以查看当前状态。 注2：markdown语法&#xA;3.2 设计实现 上面实际上设计了两个最简单的网页，并且实现了跳转。其实和你现在正在看的这个差的已经不多了（没开玩笑）。无非是我的这个网页多了一些图片，文字更多，并且有了排版。&#xA;网页的底层设计逻辑是样式+文字，样式实现是代码，文字当然还是文字。幸运的是，样式代码已经由前辈为我们准备了大量的开源的、像函数库一样的模板，我们只需要把文字当作参数传进去就可以了。文字内容被写在markdown文档里，自动变成好看的样式。也是就说，在将来实际运行的网站里，网页跳转仍旧是用上面的简单语句实现的，不需要我们进行其他多余的操作。&#xA;斜体部分暂时不明白没关系，后面还会详细的解释这个思想。&#xA;上图展示了4个Github代码仓库之间的关系，每个代码仓库都对应本地的一个文件夹，因此本地有4个同名文件夹，这里还有个本地与github的同步问题，后面工作流有介绍。&#xA;至于仓库里面的代码，当然是找现成的拿来用，也就是套模板。&#xA;4.套模板 这一步是精髓😂😂😂，用别人开源的东西装饰自己的网站，看起来很厉害的样子。实质上我就是个调包侠罢了。&#xA;模板可以去Jekyll Themes找，源码放到username.github.io仓库里就可以看到效果了。&#xA;_posts文件夹里都会有示例文章，文件名也要注意格式，比如本文的文件名为2021-07-01-website1.md，文档打开最前面就是“样式函数”&#xA;--- layout: post categories: 效率工具 title: 基于Github Pages的个人网站(1)——建站记录 date: 2021-07-29 --- 比如本文指定了使用post样式，分类到效率工具，标题为基于Github Pages的个人网站(1)——建站记录，显示创建日期为2021-07-29，理解为函数与参数的关系没有任何问题。后面的所有正文实际上也可以理解为参数。&#xA;Jekyll将构成一个网站原始文件分为模板和内容两个部分，通过渲染器转化成一个完整的可发布的静态网站。这使得不懂前端的人可以专注于内容创作，用标记语言来写文章（Markdown，Textile，HTML），然后Jekyll就会帮我套入一个布局中，生成的就是自己的主页。/* 官网复制 */&#xA;网站的底层是html+css，这个工具将网页代码做了封装，文章标题内容就像函数参数一样传递到布局上。参考这篇文章的源文件，和你现在看的做一下对比。我在写这篇文章的时候完全没有考虑格式的问题，只是使用了简单的markdown语法，这也是使用这个工具建立个人网站的原因之一，它足够简单。&#xA;其中要关注的其他文件夹：&#xA;_layouts：文章的模板。有点函数的意思，文件名类比函数名，不同的文件是不同的布局样式。&#xA;_includes：包含到布局或文章中可以被重复使用，有点头文件的意思。&#xA;此外，&#xA;_config.yml文件保存全局配置数据，包含许多网页自带功能开关设置。 GitHub pages通过这些文件自动生成一个可以访问的网站，如果编译错误会发个邮件提醒&#xA;编译出错 具体的文件里的代码，本来想写点东西的，但是感觉我也完全不懂HTML，还是不乱输出没用的内容了。总之我的方法就是：多试试。删掉以后看看哪里会出问题，那么这块代码基本上就是管这个功能的😂😂😂。&#xA;5.工作流 这里要说git与Github同步的问题，详细的教程，可以参考这个书：《GitHub入门与实践》。</description>
    </item>
    <item>
      <title>基于Github Pages的个人网站(2)——文字样式</title>
      <link>https://xym.work/blog/jekyll2.html</link>
      <pubDate>Thu, 29 Jul 2021 19:01:48 +0530</pubDate>
      <guid>https://xym.work/blog/jekyll2.html</guid>
      <description>markdown基本文字效果 复制自@果冻虾仁&#xA;该文件用来测试和展示书写README的各种markdown语法。GitHub的markdown语法在标准的markdown语法基础上做了扩充，称之为GitHub Flavored Markdown。简称GFM，GFM在GitHub上有广泛应用，除了README文件外，issues和wiki均支持markdown语法。&#xA;列表目录+超链接：&#xA;横线 标题 文本 普通文本 单行文本 多行文本 文字高亮 换行 斜体 粗体 删除线 图片 来源于网络的图片 GitHub仓库中的图片 链接 文字超链接 链接外部URL 链接本仓库里的URL 锚点 图片链接 列表 无序列表 有序列表 复选框列表 块引用 代码高亮 表格 表情 diff语法 横线 ***、&amp;mdash;、___可以显示横线效果&#xA;*** --- ___ 标题 # 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题 文本 普通文本 这是一段普通的文本&#xA;单行文本 Hello,大家好，我是果冻虾仁。 在一行开头加入1个Tab或者4个空格。&#xA;文本块 语法1 在连续几行的文本开头加入1个Tab或者4个空格。&#xA;欢迎到访 很高兴见到您 祝您，早上好，中午好，下午好，晚安 语法2 使用一对各三个的反引号：&#xA;欢迎到访 我是C++码农 你可以在知乎、CSDN、简书搜索【果冻虾仁】找到我 该语法也可以实现代码高亮，见代码高亮</description>
    </item>
    <item>
      <title>Markdown Template</title>
      <link>https://xym.work/blog/markdown-template/</link>
      <pubDate>Fri, 01 Jan 1999 19:01:48 +0530</pubDate>
      <guid>https://xym.work/blog/markdown-template/</guid>
      <description>SVG Testing Flag of India&#xD;SVG Shortcode Test Flag of India&#xD;hi testing&#xA;This is some random text to test a SVG in between the text. So, keep reading through this text until you see a svg. Still don&amp;rsquo;t see it? Wait for it. It is going to take a while before you see it. Waiting&amp;hellip; Waiting&amp;hellip; Lorem ipsum should have been used here :/. Any way, here you go Flag of India&#xD;.</description>
    </item>
  </channel>
</rss>
