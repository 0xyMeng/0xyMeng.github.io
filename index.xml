<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Home on xym-ee</title>
    <link>https://xym.work/</link>
    <description>Recent content in Home on xym-ee</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 20 Aug 2024 13:00:00 +0800</lastBuildDate>
    <atom:link href="https://xym.work/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>[post]静态网站搭建中有关计算机网络相关的内容</title>
      <link>https://xym.work/blog/hugowebsite.html</link>
      <pubDate>Tue, 20 Aug 2024 13:00:00 +0800</pubDate>
      <guid>https://xym.work/blog/hugowebsite.html</guid>
      <description>0. 介绍 需求 1：我需要有个个人网站 hugo 、github pages 需求 2：我需要在局域网中开发和调试 端口转发，NAT 需求 3：我想要更快的访问速度 云服务器部署网页，nginx 需求 4：我想在外网访问内网的机器开发和调试 内网穿透，frp 需求 5: 我还想要更好的体验 软路由、定时任务。问问 chatgpt 1. hogo 生成静态页面 在 ubuntu 环境下开发，ubuntu 安装于虚拟机中，采用桥接网卡方式上网。IP 10.0.0.22&#xA;使用了 terminal-hugo-theme 主题，按照 README 中的说明，在本地生成静态页面并启动一个本地的网页服务器，&#xA;hugo server --buildDrafts --disableFastRender --gc --ignoreCache --noHTTPCache --forceSyncStatic --verbose -w 指令的参数&#xA;--buildDrafts: 生成静态页面时为草稿的内容 --disableFastRender: 禁用快速渲染(只会重新生成发生变化的部分)，确保在每次更改时全部重新生成 --gc: 垃圾回收，清理未使用的文件 --ignoreCache: 强制忽略缓存并重新构建所有文件，确保生成的时最新的 --noHTTPCache: 禁用 HTTP 缓存，强制浏览器从服务器加载站点，确保从浏览器看的到是最新的 --forceSyncStatic: 强制同步静态文件（例如图片、CSS、JS），即使 Hugo 认为它们没有更改。确保所有静态资源都是最新的 --verbose: 输出更多信息 -w: 是 --watch 的缩写，监视文件系统的更改，并在文件修改时自动重新构建站点 hugo 的本地网页服务器监听 1313 端口，生成后，在 ubuntu 的浏览器中访问 http://127.</description>
    </item>
    <item>
      <title>💬 About Me</title>
      <link>https://xym.work/about.html</link>
      <pubDate>Thu, 28 Mar 2024 15:00:00 +0000</pubDate>
      <guid>https://xym.work/about.html</guid>
      <description> 教育与工作经历 📅 💼 🛠 2022.9 - 至今 硕士在读 导航、制导与控制专业，毕业时间 2025.4 2021.2 - 2022.9 嵌入式软件工程师 移动机器人、运动控制、rt-thread、单板软硬件 2020.6 - 2021.1 MCU 开发工程师 线控底盘，单板软硬件开发 2016.9 - 2020.6 本科在读 电气工程及其自动化专业，电力电子与电机方向 </description>
    </item>
    <item>
      <title>📝 Notebook</title>
      <link>https://xym.work/notebook.html</link>
      <pubDate>Thu, 28 Mar 2024 15:00:00 +0000</pubDate>
      <guid>https://xym.work/notebook.html</guid>
      <description>我的学习笔记，点击大标题进入查看，笔记状态&#xA;⚪ 仅框架，待整理 🟡 有内容，待完善 🟢 内容完整 计算机技术与嵌入式开发 🟡 1-1.编程语言、编译过程、数据结构与算法基础 🟡 1-2.计算机系统基础 CSAPP 🟡 1-3.数字电路、计算机组成原理、steam：图灵完备 🟢 1-4.计算机网络 🟢 1-5.操作系统原理 🟡 2-1.裸机开发，arm cortex-m cortex-a7 ⚪ 通信接口 ⚪ arm 芯片开发，基于 IDE、gcc 裸机开发 🟡 2-2.中等规模系统开发，编程思维(C 语言 OOP 思想) ⚪ 裸机 LVGL 图形库 ⚪ 裸机开发的软件框架，系统架构，(状态机、订阅发布、事件触发、任务调度) 🟡 基于 rtos 开发 (rt-thread 和 freeRTOS) 🟡 2-3.ARMv7-M 架构与 RTOS 原理 🟡 Cortex-M3 内核，指令集、中断、体系结构等 🟡 rt-thread 内核、驱动 ⚪ 3-1.linux 应用开发(系统编程+GUI) ⚪ ubuntu 相关、linux 使用、shell 编程、vim、gcc、makefile ⚪ linux 系统编程、网络编程、多线程 🟢 3-2.</description>
    </item>
    <item>
      <title>构建最小 Linux 系统</title>
      <link>https://xym.work/blog/minimal-linux.html</link>
      <pubDate>Mon, 17 Jul 2023 19:01:48 +0530</pubDate>
      <guid>https://xym.work/blog/minimal-linux.html</guid>
      <description>Linux 世界中的应用程序 (从零开始构建 “最小” Linux) [南京大学2023操作系统-P16] (蒋炎岩) 16. Linux 操作系统 为了努力的理解操作系统，学习过程中的一个想法：能不能控制电脑启动后加载的第一个程序。&#xA;事实上，电脑启动到出现桌面，这个过程并不简单。先不讨论 bootloader 阶段，只说 linux kernel，即一个想法：控制 kernel 启动后加载的第一个程序。kernel 启动后加载的程序都放在存储介质里，即存储介质里的东西不需要那么多，目录足够简单。&#xA;linux 一般仅指 kernel，根目录下的所有东西为根文件系统。构建最小 Linux 系统的完整说法：构建根文件系统最小的linux系统。&#xA;如果查看 pstree ，可以看到进程之间的关系&#xA;QEMU 下模拟 希望在给定的 linux 内核初始化完成后，直接执行我自己编写的静态链接的 init 二进制文件，我该怎么做。&#xA;查看手册得知，kernel init 函数中，会尝试按顺序执行一些东西&#xA;if (!try_to_run_init_process(&amp;#34;/sbin/init&amp;#34;) || !try_to_run_init_process(&amp;#34;/etc/init&amp;#34;) || !try_to_run_init_process(&amp;#34;/bin/init&amp;#34;) || !try_to_run_init_process(&amp;#34;/bin/sh&amp;#34;)) return 0; 这便是启动的第一个进程，如果一个都没找到，那么就会 kernel panic。&#xA;QEMU 中可以用参数指定启动的系统镜像，从而不需要考虑 bootloader 的事情，因此先在 x86 平台做这个事情。为此我们需要准备 内核镜像与根文件系统里的东西。&#xA;内核镜像可拿一个现成的来用 /boot/vmlinuz ，&#xA;按照 linux 约定的方式，把我们自己的可执行文件放到 bin 里&#xA;准备好了所有东西，把这些东西打包起来&#xA;cd rootfs find .</description>
    </item>
    <item>
      <title>C 语言实现 PID 控制算法</title>
      <link>https://xym.work/blog/pid-in-c.html</link>
      <pubDate>Fri, 13 Jan 2023 19:01:48 +0530</pubDate>
      <guid>https://xym.work/blog/pid-in-c.html</guid>
      <description>实时控制在嵌入式平台上完成，ARM 内核的 MCU 主流开发语言还是 C 语言，花点时间去实现一个通用的 PID 控制器是值得的。这里使用 webots 仿真一个平衡车来验证控制器实现的正确性。&#xA;平衡车和倒立摆的原理基本一致，可以参考另一个倒立摆 MATLAB 仿真的文章。&#xA;PID 离散表达 一个使用 PID 控制器的控制系统结构如图&#xA;其中 PID 控制器串在前向通路上，所以这是一个串联校正装置。PID 控制器内部的结构如下图&#xA;数学表达式为&#xA;$$ u(t) = K_p e(t) + K_i \int e(t) \text{d}t + K_p \frac{\text{d}e(t)}{\text{d}t} $$&#xA;这是个连续函数的表达式。计算机程序是离散时刻运行的，我们还需要得到离散化的表达式。也很容易，离散时间定义域里的求和就是连续时间的积分，离散的差分就是连续的微分。则离散时间定义域下 PID 控制器的表达式为&#xA;$$ u(k) = K_p e(k) + K_i \sum e(k) + K_p (e(k) - e(k-1)) \tag{1} $$&#xA;式(1)就是位置式PID。&#xA;相邻两次控制输出的增量为：&#xA;$$ \begin{array}{rcl} \Delta u(k) &amp;amp;= &amp;amp;u(k) - u(k-1) \ &amp;amp;=&amp;amp; K_p [e(k) - e(k-1) ] + K_i e(k) + K_d [e(k) - 2e(k-1) + e(k-2)] \ \ u(k) &amp;amp;=&amp;amp; u(k-1) + \Delta u(k) \ \end{array}\tag{2} $$</description>
    </item>
    <item>
      <title>计算机系统实践：Cheat Engine开发游戏修改器</title>
      <link>https://xym.work/blog/cheat-engine.html</link>
      <pubDate>Fri, 28 Jan 2022 19:01:48 +0530</pubDate>
      <guid>https://xym.work/blog/cheat-engine.html</guid>
      <description>（待完善）&#xA;官网介绍：Cheat Engine是一个主要用于修改游戏和应用程序的开发环境。&#xA;也就是说CE是一个和游戏修改器差不多的东西，改物品栏数值、锁血啥的，但是普通游戏修改器是个现成的程序一键操作完成，CE是个开发环境，功能相当强大。&#xA;CE最终目的并不是去改游戏，更重要的，是对计算机组成原理、微机原理、汇编、程序与数据理论知识的应用。在游戏修改器开发过程中计算机知识的实践，这种快乐程度要比在8086虚拟环境上多得多。&#xA;既然是游戏修改，就涉及到一个游戏道德甚至是法律问题，对于单人游戏，个人认为怎么搞随便，至于多人游戏，有反作弊机制，更严重的“破坏计算机信息系统罪”适用于制作外挂并传播这一行为。&#xA;这个工作涉及到CPU工作原理、内存、x86指令集，理论知识，CE使用方法、工作流程，数据修改与指令修改。&#xA;GitHub: Cheat Engine. A development environment focused on modding&#xA;Cheat Engine wiki&#xA;游戏的运行与CE原理 CPU是逻辑电路，进行简单的逻辑运算，游戏执行最终落实到CPU上是一系列指令。因此最终CPU运行的就是一条一条指令。&#xA;CPU工作很呆板，就是执行一条条指令，通过指令操作数据对数据进行读和写。&#xA;比如游戏背包里的物品个数，这就是数据，物品数量变化，CPU进行加减就可以。&#xA;事实上，指令和数据是编码的形式存在在电脑内部的。&#xA;如果只有这么一串01，理论上讲是无法区分到底是指令还是数据，CPU是靠上下文来判断的。电脑开机后CPU读到的第一个字节必然是指令，每条指令里会指示后面的编码是指令还是数据。所以，改数据和改指令从编码层次上来看是一样的。&#xA;如果要修改编码，我们就得知道这些编码保存在哪里，肯定不是CPU，事实上存在内存里，指令和数据都是从内存里面取出来的，所以我们改程序实际上是在改内存里的编码。&#xA;CE的工作原理就是监控任意一个应用程序使用的全部内存，并且可以随意修改编码。这样一来，理论上就可以对游戏进行任何操作。&#xA;比如说，找到了血量的存储位置，并冻结数据，这就锁血了。或者找到“减”指令，换成空指令，或者直接变成加，这就挨打了还加血。&#xA;综上，CE修改的思路也就是很简单两步：&#xA;1.找到感兴趣的编码在内存里的位置 2.修改编码 数据 指令 数据和指令没有区别，都是编码&#xA;计算机编码是二进制的，但是为了表达方便，用字节为单位使用16进制表示。&#xA;数据修改 基本操作 最简单的用法，根据精确的数值行为定位内存地址。多次筛选后，就可以找到生命值所在的内存地址，可以直接修改数值。&#xA;如果不知道具体数值，比如说只有个血条，那么使用未知初值的选项进行第一次搜索，然后使用数值行为，比如说正在减少或者减少的具体值这些特征来筛选对应的内存地址。&#xA;数据类型也是个需要关注的问题。&#xA;内存数据结构 单次修改保存了变量列表，下次打开以后，发现这个表已经变了。如果要反复使用该如何操作呢？&#xA;内存从下往上看，&#xA;指令|数据（全局、堆、栈）&#xA;堆是随便分配加回收的，栈倒是连续的，但是栈的其实位置随机的。&#xA;因此指令的位置是固定的，堆和栈里的数据位置不固定，因此重新运行的游戏就不知道了。&#xA;但是游戏自己肯定是知道堆栈地址在哪里的。通过指针指向堆栈数据。&#xA;那么我们也可以和游戏一样，通过源头指针一路找到血量。&#xA;指针追溯 追溯到全局变量段就可以了。&#xA;手动追溯，对数据结构的深入理解。&#xA;查找到具体数值所在的内存后，可以直接查找这个内存地址，查看是什么指令在访问这个内存，就可以找到这个地址的指针。直接使用指针来操作数据，在每次游戏重启后，同样也是可以用的。&#xA;要注意的是，有时候数据定义在一个结构体内（或者是一个类），寻址方式是基地址+偏移地址，因此需要计算出偏移地址。可以在手动添加指针的时候设置偏移地址。&#xA;实际游戏这么一级指针还是有点简单了，更多情况下是好多级指针，在上层程序设计的时候有数据的继承，在汇编层次上就是多次指针跳转。每次跳转实际上是跳转到结构体的基地址了，因此要注意每一次跳转的偏移地址。追溯到绿色名称就可以停下了，这一段是指令段。&#xA;手动追溯指针需要非常了解数据结构以及编译后的数据存储方式。自动追溯会容易一点，首先找到血量所在的地址，使用指针扫描，然后瑞出游戏重新进入。再次找到血量的地址，找出相关指针，取个交集。大概就是这么个思路，因为偏移量总是固定的，交叉比对出我们需要的指针。&#xA;最后，如果数据的源头也不在全局变量里，那这修改数据就行不通了，然而指令肯定是在固定位置的。这时候就得使用改指令的方法了。&#xA;指令修改 x86指令集 指令集和机器码差不多（真指令），可以等价起来。机器码给给机器读，汇编给人看更容易一点。&#xA;CPU里的寄存器数量有限，速度快数量少。x86对应的寄存器只有16个，除了寄存器，还需要了解一下寻址方式和常用的指令。&#xA;MOV ECX, [RSI + 07E0]&#xA;机器码的格式，指令编码的长度是不固定的，简单知道编码格式&#xA;操作码 数据1 数据2&#xA;指令修改思路 这也是个去哪里干什么的事情。</description>
    </item>
    <item>
      <title>三相异步电动机矢量控制 MATLAB 仿真</title>
      <link>https://xym.work/blog/motor-foc.html</link>
      <pubDate>Tue, 18 Jan 2022 19:01:48 +0530</pubDate>
      <guid>https://xym.work/blog/motor-foc.html</guid>
      <description>矢量控制或者FOC控制近些年逐渐走进日常消费电器了，在一些洗衣机，电动玩具的广告里甚至可以直接看到这个词，我觉得这对消费者来说要求还是有点高了😂😂。&#xA;FOC控制大规模的商业应用也能看出这是一种相当成熟的电机控制方法了，这里做一个异步电机的矢量控制仿真总结。&#xA;矢量控制基本思想 矢量控制这个名字的由来是控制方法里有坐标变换（矢量变换），FOC控制的全名是按照转子磁链定向控制，其含义是在坐标变换后把旋转坐标系的d轴方向固定在转子磁链方向。往往伴随的还有SVPWM这个词，这是一种调制方法，可以提高电压利用率，矢量控制不一定必须用到SVPWM的调制方法。&#xA;矢量控制系统比较复杂，整个系统由很多部分或者叫模块构成，每个模块又有不止一种方法实现，但是使用不同方法的模块实现的功能是一样的。因此比较先进的控制方法也是在整个老的系统结构上去优化一个模块。一个典型的就是无传感器控制，实际上是状态观测器用作传感器。&#xA;首先梳理一下矢量控制的基本思想：&#xA;对于他励式直流电动机来说，接线端子4个，两根为励磁绕组引出，两根电枢绕组引出，磁通和电枢电流可以分开单独控制，磁通恒定后电磁转矩就只和电枢电流有关了。&#xA;对于三相异步交流电机来说，接线端子有6个，如果是接成了Y型不引出中心线，那么端子有3个，这三根线进去的电流有一部分产生磁通，一部分产生电磁转矩，混叠在一起。这也是交流电机控制复杂的原因。&#xA;矢量控制的基本方法是使用坐标变换（矢量变换），核心思路就是把混叠在一起励磁电流和电枢电流分开来，单独控制励磁电流恒定，这样转矩就可以单独由电枢电流控制，和直流电机一样了。坐标变换只是我们看待问题的视角变了，实际电机物理系统的磁动势和功率是个客观量，因此变换原则是保持磁动势不变。分解出励磁电流和电枢电流后，按照给定值加以控制后，还需要再合成三相电流的给定值，让实际电流跟随三相给定电流。这就是基本的矢量控制思路。&#xA;根据上面的描述，关注这几个细节：&#xA;如何进行坐标变化。参考系的选取，怎么变才能达到分解电流为励磁分量和转矩分量。&#xA;转子磁链定向问题。在坐标变换中有个坐标系是和转子磁链一同旋转的，因此我们需要知道转子磁链的角度，在对励磁电流进行控制时，也需要知道磁链大小，因此转子磁链计算是要解决的一个问题。&#xA;PWM调制方式。电子电子变压变频器都是要去使用脉冲宽度调制的。在使用PWM时有个小问题，日常家用电220V，如果使用SPWM去产生220V的交流电，使用220V直流电做不到，日常讲的220V交流电是有效值，其标准的数学表达式为$$ u(t) = 220\sqrt{2}\sin(\omega t + \varphi) $$，因此如果使用SPWM调制方法，需要的直流电源为$$ 220\sqrt{2} \approx 311 \mathrm{V} $$，如果要产生有效值380电压的交流电，需要的直流电源约为537V。这就感觉很不舒服，因此如何用电压更小的直流电源产生有效值更大交流电，也是个需要解决的问题。&#xA;如果这几个细节都清楚了，那么矢量控制的核心原理及方法大概也就搞明白了。&#xA;在整个矢量控制细节结构上，还可以进行一些优化改进，比如：&#xA;进行转矩控制提高动态。这是矢量控制里的转矩控制，区别另一种思想直接转矩控制。虽然励磁电流和电枢电流解耦了，但是在控制励磁电流跟随给定的时候还是会有波动，因此为了更好的动态性能，在转矩波形影响转速前就对其进行控制，有两个常用的方法。&#xA;无传感器控制。转速控制需要转速值，一些磁链计算方法也要转速值，现在转速传感器也不想要了，使用算法充当转速传感器，比如状态观测器等一些转子位置估计方法，这也是近些年电机控制的一个新话题。&#xA;以上这些点，后面的仿真都会出现。&#xA;接下来就要开始做仿真了。&#xA;仿真电机参数 被控对象为一台三相笼型异步电动机(Triple-phase asynchronous motor)，铭牌参数：&#xA;额定功率$$ P_N = 3\mathrm{kW} $$ 额定电压$$ U_N = 380 \mathrm{V} $$ 额定电流$$ I_N = 6.9 \mathrm{A} $$ 额定转速$$ n_N = 1400 \mathrm{r/min} $$ 额定频率$$ f_N = 50 \mathrm{Hz} $$ 极对数$$ n_p = 2 $$ 定子绕组$$ \mathrm{Y} $$联结 由实验测得的数据：</description>
    </item>
    <item>
      <title>学git和Github——项目管理与合作开发</title>
      <link>https://xym.work/blog/git.html</link>
      <pubDate>Sun, 09 Jan 2022 19:01:48 +0530</pubDate>
      <guid>https://xym.work/blog/git.html</guid>
      <description>github 和 git GUI git CLI https://learngitbranching.js.org/?locale=zh_CN&#xA;git 和 github 的连接 前言 在本科参加比赛的时候，我和我的队友们一共3个人，每个比赛也都算是一个小项目，使用C语言开发单片机，当时还没有项目版本管理的概念。合作方式是基于压缩包与U盘的，分支靠文件夹重命名，合并就是复制替换。&#xA;在搞毕业设计的时候，也有一种类似的文档版本管理方式：&#xA;这大概就是版本管理的初级设想吧。&#xA;git就是这样一个工具，可以实现本地的、细致到字符级别的版本管理。&#xA;比如git记录了我对一个文档的第176行指令的修改。&#xA;Github是另一个东西，云端，和本地照片备份到云端是一个性质。也就是说如果写代码只是自己一个人写着玩玩，也不需要合作，也不想给别人看，只有个git就可以实现版本管理了。同步到云端Github会让所有人看到具体内容，有了更多的社交属性在里面。&#xA;从Github下载、上传到Github 一个软件的用法，我认为还是思路最重要，逐步操作放到最后面，理解了思路以后，再看的逐步教程也就知道自己是在干嘛了。看逐步教程容易被淹没在指令里😂😂，我觉得对一个纯新人不是很友好。&#xA;下面出现的一些措辞不严谨，只是为了更好理解，所以用了日常使用软件的一些说法。在文章最后会全部替换为准确说法，并与指令对应起来。&#xA;首先装软件，安装好git和gitahead，然后要有个Github的账号。可以认为gitahead是我们用来上传下载的工具。&#xA;先尝试从Github（云端）下载一些东西下来。比如说我在云端有个代码库叫learning，首先打开gitahead，需要登录自己的GitHub账号。中间巨大的Add Github account，也可以点击左下角的“+”也有这个选项。&#xA;弹出窗口的Username就是Github的用户ID，但是密码不是登陆密码，这个类似于邮箱二次验证。去Github网页端进入设置页面，在Developer settings里，找到Personal access tokens，生成一个新的长密码就行，下面所有的框全选上，可以选择长期有效。用新生成的密码就可以登录gitahead了。&#xA;登陆后，要在tools-options里填上自己的邮箱地址。&#xA;这时候左列出现了云端的东西，可以直接下载。这就有网盘的感觉了，还挺好使。&#xA;现在要往learning这个云端仓库上传一个文件试试，去刚下载下来的这个learning里面，新建一个新建文本文档.txt，也可以打开随便写点东西保存后来上传。&#xA;上传稍稍有点不一样，要多操作几步（后面会拆开来说原因），左边选中Uncommitted changes，上边的框框点击Stage All，然后点击Commit，最后工具栏里会多出一个红色的1，鼠标移过去显示“Push”，点一下就完成上传了。&#xA;合理猜测Push左边的Pull是不是可以下载。&#xA;虽然这个东西上传有点麻烦，但是也不是很麻烦。&#xA;版本管理 其实在上面上传的时候已经有点版本管理的感觉了。这个Push更准确的含义应该是向云端同步，那么pull的含义是云端向本地同步。&#xA;前面说过，git是本地版本管理软件，也就是说Push操作已经是在本地管理完了，要同步到云端公开鉴赏了。&#xA;那么显然Stage All，Commit就是在本地进行版本管理。Commit是提交文件修改到本地，Stage All是暂存修改。&#xA;可以随便改改提交试试，这种全新的版本管理还是很不错的。&#xA;左边有条线串起了每个版本，这根线串起来的就是一个分支。目前仅有一个分支。&#xA;回退也很简单，随便挑一个版本，右击，选reset-hard是最简单粗暴的方式。至于各个方式的区别，不同方式略有区别。可以多试试一些操作，软件这个东西，玩不坏的，不行就重启试试。再不济删掉重来。&#xA;分支操作 一个分支够了。后面有时间再写吧。&#xA;其实熟悉本地版本管理和远程同步，一个分支操作熟悉了以后，用图形界面客户端跟着感觉按按，也能按出来。这也是使用gitGUI的一个优点吧。&#xA;贡献代码 很多时候，我们不止想单兵作战。还想邀请亲朋好友一起写代码，如果离得近还科技基于U盘进行代码分发，基于压缩包进行版本管理。&#xA;但是现在有git做版本管理了，也想用起来。一个思路是大家有一个公共仓库，每个人都可以向提交自己的仓库一样提交文件公共仓库。这就是Github里organization的作用。&#xA;对于一些大开源项目，这样不合适，不能随便一个人都随便提交，任意修改，总会有人想搞破坏。所以还要有一种需要审核的提交文件的方式。&#xA;比如说如果我最近看到一个挺不错的电气电子控制的课程资料项目https://github.com/Control-and-Engineering/course-materials-backup，正好手上有一份资料可以贡献一下，这个项目仓库属于一个叫 Control-and-Engineering的人。显然这不是属于我的仓库，不会在gitahead左侧出现，我无法直接上传到这个仓库里。&#xA;首先得让这个仓库属于我，Github给出的方法是Fork一份，就像用U盘复制一份一样，从 Control-and-Engineering的云端空间复制到我的云端空间。&#xA;这时候我的云端就有一个一模一样的备份了，这是属于我的，所以我可以任意修改。改好以后，同步到我的云端，这时候其实再从我的云端“复制”到 Control-and-Engineering的云端就好了。这就是页面上的Contribute，可以看到里面的按钮是Open pull request这是一种需要请求的贡献方式，也更广泛的使用。&#xA;上传大文件(&amp;gt;100MB) 安装git-lfs，然后点击githaead里的工具栏Submodule，Configure Submodules，选最后一个LFS。然后初始化。&#xA;git lfs install #安装大文件上传应用 git lfs track &amp;#34;*.</description>
    </item>
    <item>
      <title>PID控制器、串联校正装置理论分析和性能对比</title>
      <link>https://xym.work/blog/pid-controller.html</link>
      <pubDate>Fri, 19 Nov 2021 19:01:48 +0530</pubDate>
      <guid>https://xym.work/blog/pid-controller.html</guid>
      <description>经典控制理论在频域或者复频域分析系统的性能。&#xA;复频域s平面，闭环极点决定了系统稳不稳，闭环零点影响系统性能&#xA;频域则使用相位裕度来衡量系统性能，更简洁有力，系统阶数越高，频域方法使用起来越优越。&#xA;PID控制器从零极点的角度考虑，引入了新的零点极点，从频域考虑，则是一类特殊的串联校正装置，所以先总结一些零极点定性的的结论，然后&#xA;零点极点对系统的影响 闭环极点，模态，系统响应由模态叠加。负实根，模态收敛，共轭虚根，处理一下是三角函数，即震动，实部为包络线，实部为负，震动收敛。&#xA;更多情况下并不直接讨论闭环极点，而是从开环出发分析系统的闭环性能。&#xA;比如复频域里的根轨迹法，通过开环零极点位置，来判断参数调整对闭环极点位置的影响。&#xA;频域里，通过开环对数幅频、对数相频图，判断闭环系统的稳定性、稳定程度。&#xA;各类控制器对比 PID&#xA;比例控制器&#xA;$$ G_c(s) = K $$&#xA;PI控制&#xA;$$ G_c(s) = K_P + K_I\frac{1}{s} = \frac{K_Ps+K_I}{s} $$&#xA;$$ G_{PI}(s) = K \frac{Ts+1}{s} $$&#xA;PD控制&#xA;$$ G_c(s) = K_P + K_D \cdot s $$&#xA;$$ G_{PD}(s) = K (Ts+1) $$&#xA;PID控制&#xA;$$ G_c(s) = K_P + K_I \cdot \frac{1}{s} + K_D \cdot s = \frac{ K_P\cdot s + K_I + K_D \cdot s^2 }{s} $$</description>
    </item>
    <item>
      <title>二维向量场可视化工具与相平面图</title>
      <link>https://xym.work/blog/field-play.html</link>
      <pubDate>Sun, 31 Oct 2021 19:01:48 +0530</pubDate>
      <guid>https://xym.work/blog/field-play.html</guid>
      <description>1.二维向量场 这篇文章介绍了一个平面向量场可视化的网页工具：fieldpaly&#xA;这里只是介绍了系统相平面可视化实现的代码，给出了我定义的系统代码标准型，如果对相平面、非线性系统、状态空间、微分方程解的性质等控制的理论内容感兴趣，可以参考我的笔记：相平面法-工程中的数学&#xA;从纯数学的角度来讲，这是一个画二维向量场的网站。二维向量场的数学表达：&#xA;$$ \boldsymbol{A} = (P,Q) = P(x,y) \cdot \boldsymbol{i} + Q(x,y) \cdot \boldsymbol{j} $$&#xA;平面向量场$$ \boldsymbol{A} $$与位置相关，一般纸面上的表达方式是平面上每个点都有一个带箭头的向量。&#xA;可视化的表达方式更加直观，通过粒子的运动就能反映向量场的情况。&#xA;按照“速度矢量和位置相关”的思路，这个可视化网页提供了一个接口，入口参数为位置，返回参数为该点速度，函数体内可以自己实现数学关系。&#xA;vec2 get_velocity(vec2 p) { vec2 v = vec2(0., 0.); /* p与v的数学关系实现 */ return v; } 举个例子，可视化一个点电荷形成的电场。&#xA;在原点放置一点电荷带电量为$$ -q $$，试探电荷带电量$$ +q^* $$，其所在位置为$$ \vec r $$&#xA;试探电荷受到的力为&#xA;$$ \vec F = -k\frac{qq^*}{r^2}\cdot\vec {r^°} $$&#xA;则电场强度为&#xA;$$ \vec E = \frac{\vec F}{q^*} = -k\frac{q}{r^2}\cdot\vec {r^°} $$&#xA;取$$ kq = 1 $$，那么这个电场的表达式为</description>
    </item>
    <item>
      <title>基于Simscape的倒立摆控制算法仿真</title>
      <link>https://xym.work/blog/simscape.html</link>
      <pubDate>Thu, 19 Aug 2021 19:01:48 +0530</pubDate>
      <guid>https://xym.work/blog/simscape.html</guid>
      <description>各种现代控制方法层出不穷，但是PID万古长青。纵使你理论发展又快又好，工业上还是PID占据了大半江山。没事整整PID还是挺有用的。&#xA;仿真对象 这里用倒立摆作为仿真对象，对各种花式PID的控制效果进行比较。通过对倒立摆这一典型的非线性系统的控制，可以检验各种PID控制方法是否有较强的处理非线性和不稳定性问题的能力。&#xA;常用的机器人仿真工具有Gazebo、Webots、MATLAB等，这里使用到的是MATLAB中的Simscape Multibody模块，MATLAB版本为2019b。Simscape 是 Simulink 的一个模块，而 Simscape Multibody 又是 Simscape 的一个模块。这个模块是一个多体机构仿真环境，提供了几何体、关节、约束、施力单元以及传感器等大量的组件，这使得在MATLAB中搭建一个机构仿真框图十分容易，同时模块集成了3D可视化组件，这使得仿真结果更为直观。&#xA;搭建一个倒立摆的模型，&#xA;设置好各种物理参数，输出4个传感器数据作为反馈参数（不一定都要用到，先留着），打包成一个subsystem。直接启动仿真，可以看到在没有外力所用下，只要有轻微干扰，倒立摆就直接倒了。&#xA;然后把摆杆角度作为反馈，直立状态作为给定计算得到偏差，把摆杆初始角度调成左偏30°，然后随便整两个PD参数，基本上就能立起来了。&#xA;系统结构是下面这个样子，这个结构就代表了很大一类的简单控制系统，比如温度控制、液位控制等。&#xA;控制效果&#xA;当然也可以加上位置控制，看起来更像比较厉害的控制理论。要做的就是在角度控制的基础上串上个位置控制&#xA;对于一个阶跃信号的控制效果&#xA;由此可以看出，PID是个好东西。倒立摆其实并没这么简单，是个挺复杂的小东西，但是在使用PID的时候，完全没考虑其数学模型的问题，就直接让他立了起来，甚至效果还不错。PID让即使是不懂控制控制理论的人也可以随便试几个参数达到这个效果，所以PID的广泛应用也是情理之中的。当然网上讲PID的直观理解的人很多，开车的、倒水的、烧火炉的故事都有人讲过，这些故事对PID的直观理解也有很大帮助。当然PID的在数学上的作用机理没这么好理解，搞控制理论的人总是执着的用数学手段严格证明一个系统的稳定性，关于控制背后的数学原理，后面有空再写写。&#xA;再加点程序控制手段，用$\theta$和$\dot \theta$这两个参数模仿人把摆甩起来，然后偏差小到一定范围内切换角度+位置闭环控制，控制结构图如下图：&#xA;控制效果&#xA;这个启动控制看起来相当厉害，但是控制手段却是最没牌面的，坦率的讲没有用到任何控制算法，这只能叫控制方法，就是个开环盲甩，实际情况下抗干扰能力太差，随便什么参数变一下后果直接不可预测，当然这里启动不是重点，相关方法也有很多比如bangbang控制、能量反馈控制，这些都是有反馈即自动控制的核心思想在里面的。&#xA;到这里一切只是个开始，在比较早的年代，有用纯硬件搭的PID控制电路，随着嵌入式与微电子的发展，数字控制逐渐取代了模拟控制，越来越多的改进PID方法诞生了，这些改进的PID控制方法使得经久不衰的PID再次焕发了生机，这也是本文想学习仿真的东西。&#xA;理论分析 只试两个参数感觉还是差了点意思，毕竟不学控制理论的朋友稍微试试也能到这个效果，还是要理论分析一下才显得像是个学过理论的人。&#xA;理论分析的第一步就是把这个物理的东西先变成数学上的一个式子，俗称数学建模。众所周知，经典控制理论分析的是线性定常微分方程，这个倒立摆输入是力，把摆杆偏角认为是输出，那么正好凑凑能搞出的微分方程，这样就可以进一步分析了。&#xA;$$ F(t) = M \ddot{x}(t) + m [ \ddot{x}(t) + ] $$&#xA;然后工作点附近线性化一下，有了线性定常微分方程了：&#xA;$$ \left[ ml - J\left(\frac{M}{m} + 1\right) \right] \ddot\theta(t) + (M+m)g\theta = f(t)$$&#xA;然后呢，传递函数就有了，这时候，零极点、根轨迹、波特图各种分析手段都可以使用了，各种校正手段都可以用在这个微分方程上。&#xA;如果想更先进一点，可以使用状态空间来描述这个事情。&#xA;。。。。。 （有时间一定补充）&#xA;模糊控制 自适应模糊PID 状态反馈控制 二阶倒立摆状态反馈控制 二阶摆 模型&#xA;不加外力&#xA;并联PD，一般单入单出的控制，不能这么搞的，😂，这个东西不一样，本质上是状态反馈，用极点配置法求出6个反馈参数，所以看起来是并联PD，但是本质是状态反馈。&#xA;来个初始小偏差，看看效果&#xA;能立起来了。</description>
    </item>
    <item>
      <title>基于Github Pages的个人网站(1)——建站记录</title>
      <link>https://xym.work/blog/jekyll1.html</link>
      <pubDate>Thu, 29 Jul 2021 19:01:48 +0530</pubDate>
      <guid>https://xym.work/blog/jekyll1.html</guid>
      <description>1.搭主页之前 为什么我会想搭一个自己的网站呢？&#xA;首先是经验积累。把做过的东西像集卡游戏一样收集起来也是一件挺好玩的事情。其次内容洁癖，要对自己的内容有绝对的控制权，不允许有广告这种不可控内容出现在自己的页面上。&#xA;基于以上的想法，商业博客基本上就被排除掉了。一开始我用的是GitHub，.md文档可以在GitHub网页上直接展示，有一半博客的功能，而且页面相比CSDN之类的足够干净。&#xA;用了两天以后发现，在网页上只能显示文字和图片，就像上面这样。在本地的VS Code上可以通过插件实现latex公式，然而网页打开就是一串代码，当然截图插入也是个方法，最重要的是，图片大小不可控。在使用GitHub的这几天，我发现有许多人都有基于Github Pages的自己的主页，可以实现各种功能，这就正好和我的需求对上了，于是经过几天试验，有了目前这个网站。&#xA;2.整体设计思路 我的主页的内容按照下面这几个部分来设计的：&#xA;简历。突出一个个人特征。这部分是给别人看的，放在首页，如果有幸有人不小心点进了我的主页，那么不看也得看，无形之中推销自己。 传统的技术博客。类似于CSDN的中短文章，项目经历展示，开发经验积累，别人看，自己也看。 长篇幅的笔记。大节小节带数学公式，知识总结沉淀。这部分是给自己看的，顺便给别人看，当然由于内容过于臃肿我觉得进来的人几乎不会看的。 在个人简历中我会把这个网页放在一个突出位置，除了实体纸质简历，引导看我简历的人来到这个网页。进入主页直接就有个人联系方式以及社交账号，主页下拉是一个简单的个人介绍，此外还有一些项目经历和我更完整的工作技能点，详细的知识结构。对于一个陌生人来说，这是我最想让他们看到的东西。这个网站更像是个“大简历”，一个实时更新，全面展示的简历。对我感兴趣的人会点击导航栏里“关于我”查看我更详细的个人经历，对我的项目感兴趣的人会点击“我的项目”去看我的开发经验。对我知识结构感兴趣的人会点击“学习笔记”去看我的知识储备。&#xA;3.方案实现 3.1 GitHub Pages是什么 我的GitHub ID是@1xyMeng{:target=&amp;quot;_blank&amp;quot;}，新建一个名为1xyMeng.github.io{:target=&amp;quot;_blank&amp;quot;}的仓库，在仓库Setting选项卡里的GitHub Pages进行如下设置&#xA;这时候1xyMeng.github.io这个地址已经是一个可以访问的网站了。再新建一个随便什么名字的仓库，和上面一样的设置&#xA;这时候1xyMeng.github.io/learning也是一个可以访问的网站了，而且对比一下这两个地址，很有意思，找到一点感觉了。&#xA;这时候如果在1xyMeng.github.io仓库的README.md里面加一行&#xA;[点击跳转](https://1xyMeng.github.io/learning) 使用浏览器访问1xyMeng.github.io，可以看到多出来的一行内容，点一下果然会跳到learning页面。&#xA;以上就是我的网站的最基本的逻辑。把仓库里的内容变成一个可以访问的网页就是GitHub Pages帮我们办到的事情。&#xA;注1：修改了文件后，需要等几分钟，毕竟GitHub Pages帮我们办事情也是要花时间的，在仓库右侧Environments可以查看当前状态。 注2：markdown语法&#xA;3.2 设计实现 上面实际上设计了两个最简单的网页，并且实现了跳转。其实和你现在正在看的这个差的已经不多了（没开玩笑）。无非是我的这个网页多了一些图片，文字更多，并且有了排版。&#xA;网页的底层设计逻辑是样式+文字，样式实现是代码，文字当然还是文字。幸运的是，样式代码已经由前辈为我们准备了大量的开源的、像函数库一样的模板，我们只需要把文字当作参数传进去就可以了。文字内容被写在markdown文档里，自动变成好看的样式。也是就说，在将来实际运行的网站里，网页跳转仍旧是用上面的简单语句实现的，不需要我们进行其他多余的操作。&#xA;斜体部分暂时不明白没关系，后面还会详细的解释这个思想。&#xA;上图展示了4个Github代码仓库之间的关系，每个代码仓库都对应本地的一个文件夹，因此本地有4个同名文件夹，这里还有个本地与github的同步问题，后面工作流有介绍。&#xA;至于仓库里面的代码，当然是找现成的拿来用，也就是套模板。&#xA;4.套模板 这一步是精髓😂😂😂，用别人开源的东西装饰自己的网站，看起来很厉害的样子。实质上我就是个调包侠罢了。&#xA;模板可以去Jekyll Themes找，源码放到username.github.io仓库里就可以看到效果了。&#xA;_posts文件夹里都会有示例文章，文件名也要注意格式，比如本文的文件名为2021-07-01-website1.md，文档打开最前面就是“样式函数”&#xA;--- layout: post categories: 效率工具 title: 基于Github Pages的个人网站(1)——建站记录 date: 2021-07-29 --- 比如本文指定了使用post样式，分类到效率工具，标题为基于Github Pages的个人网站(1)——建站记录，显示创建日期为2021-07-29，理解为函数与参数的关系没有任何问题。后面的所有正文实际上也可以理解为参数。&#xA;Jekyll将构成一个网站原始文件分为模板和内容两个部分，通过渲染器转化成一个完整的可发布的静态网站。这使得不懂前端的人可以专注于内容创作，用标记语言来写文章（Markdown，Textile，HTML），然后Jekyll就会帮我套入一个布局中，生成的就是自己的主页。/* 官网复制 */&#xA;网站的底层是html+css，这个工具将网页代码做了封装，文章标题内容就像函数参数一样传递到布局上。参考这篇文章的源文件，和你现在看的做一下对比。我在写这篇文章的时候完全没有考虑格式的问题，只是使用了简单的markdown语法，这也是使用这个工具建立个人网站的原因之一，它足够简单。&#xA;其中要关注的其他文件夹：&#xA;_layouts：文章的模板。有点函数的意思，文件名类比函数名，不同的文件是不同的布局样式。&#xA;_includes：包含到布局或文章中可以被重复使用，有点头文件的意思。&#xA;此外，&#xA;_config.yml文件保存全局配置数据，包含许多网页自带功能开关设置。 GitHub pages通过这些文件自动生成一个可以访问的网站，如果编译错误会发个邮件提醒&#xA;具体的文件里的代码，本来想写点东西的，但是感觉我也完全不懂HTML，还是不乱输出没用的内容了。总之我的方法就是：多试试。删掉以后看看哪里会出问题，那么这块代码基本上就是管这个功能的😂😂😂。&#xA;5.工作流 这里要说git与Github同步的问题，详细的教程，可以参考这个书：《GitHub入门与实践》。&#xA;在实际上手操作之前，先来看看数据流向</description>
    </item>
    <item>
      <title>基于Github Pages的个人网站(2)——文字样式</title>
      <link>https://xym.work/blog/jekyll2.html</link>
      <pubDate>Thu, 29 Jul 2021 19:01:48 +0530</pubDate>
      <guid>https://xym.work/blog/jekyll2.html</guid>
      <description>markdown基本文字效果 复制自@果冻虾仁&#xA;该文件用来测试和展示书写README的各种markdown语法。GitHub的markdown语法在标准的markdown语法基础上做了扩充，称之为GitHub Flavored Markdown。简称GFM，GFM在GitHub上有广泛应用，除了README文件外，issues和wiki均支持markdown语法。&#xA;列表目录+超链接：&#xA;横线 标题 文本 普通文本 单行文本 多行文本 文字高亮 换行 斜体 粗体 删除线 图片 来源于网络的图片 GitHub仓库中的图片 链接 文字超链接 链接外部URL 链接本仓库里的URL 锚点 图片链接 列表 无序列表 有序列表 复选框列表 块引用 代码高亮 表格 表情 diff语法 横线 ***、&amp;mdash;、___可以显示横线效果&#xA;*** --- ___ 标题 # 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题 文本 普通文本 这是一段普通的文本&#xA;单行文本 Hello,大家好，我是果冻虾仁。 在一行开头加入1个Tab或者4个空格。&#xA;文本块 语法1 在连续几行的文本开头加入1个Tab或者4个空格。&#xA;欢迎到访 很高兴见到您 祝您，早上好，中午好，下午好，晚安 语法2 使用一对各三个的反引号：&#xA;欢迎到访 我是C++码农 你可以在知乎、CSDN、简书搜索【果冻虾仁】找到我 该语法也可以实现代码高亮，见代码高亮</description>
    </item>
    <item>
      <title>Markdown Template</title>
      <link>https://xym.work/blog/markdown-template/</link>
      <pubDate>Fri, 01 Jan 1999 19:01:48 +0530</pubDate>
      <guid>https://xym.work/blog/markdown-template/</guid>
      <description>SVG Testing Flag of India&#xD;SVG Shortcode Test Flag of India&#xD;hi testing&#xA;This is some random text to test a SVG in between the text. So, keep reading through this text until you see a svg. Still don&amp;rsquo;t see it? Wait for it. It is going to take a while before you see it. Waiting&amp;hellip; Waiting&amp;hellip; Lorem ipsum should have been used here :/. Any way, here you go Flag of India&#xD;.</description>
    </item>
  </channel>
</rss>
